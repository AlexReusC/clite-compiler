Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> Program
Rule 1     Program -> Function Program
Rule 2     Program -> empty
Rule 3     Function -> FunctionReturnType ID ( ) { Declarations Statements ReturnStatement }
Rule 4     Function -> FunctionReturnType ID ( Params ) { Declarations Statements ReturnStatement }
Rule 5     Params -> Param Params
Rule 6     Params -> empty
Rule 7     Param -> Type ID
Rule 8     ReturnStatement -> RETURN Expression ;
Rule 9     ReturnStatement -> RETURN ;
Rule 10    empty -> <empty>
Rule 11    Declarations -> Declaration Declarations
Rule 12    Declarations -> empty
Rule 13    Declaration -> Type ID ;
Rule 14    Type -> INT
Rule 15    Type -> BOOL
Rule 16    Type -> FLOAT
Rule 17    Type -> CHAR
Rule 18    FunctionReturnType -> Type
Rule 19    FunctionReturnType -> VOID
Rule 20    Statements -> Statement Statements
Rule 21    Statements -> empty
Rule 22    Statement -> Assignment
Rule 23    Statement -> IfStatement
Rule 24    Statement -> WhileStatement
Rule 25    Statement -> ForStatement
Rule 26    Statement -> ;
Rule 27    Statement -> Block
Rule 28    Block -> { Statements }
Rule 29    IfStatement -> IF ( Expression ) Statement ELSE Statement
Rule 30    WhileStatement -> WHILE ( Expression ) Statement
Rule 31    ForStatement -> FOR ( Assignment Expression ; Assignment ) Statement
Rule 32    Assignment -> ID = Expression ;
Rule 33    Expression -> Conjunction
Rule 34    Expression -> Expression OR Conjunction
Rule 35    Conjunction -> Equality
Rule 36    Conjunction -> Conjunction AND Equality
Rule 37    Equality -> Relation
Rule 38    Equality -> Relation EquOp Relation
Rule 39    EquOp -> EQ
Rule 40    EquOp -> NEQ
Rule 41    Relation -> Addition
Rule 42    Relation -> Addition RelOp Addition
Rule 43    RelOp -> <
Rule 44    RelOp -> LTE
Rule 45    RelOp -> >
Rule 46    RelOp -> GTE
Rule 47    Addition -> Term
Rule 48    Addition -> Addition AddOp Term
Rule 49    AddOp -> +
Rule 50    AddOp -> -
Rule 51    Term -> Factor
Rule 52    Term -> Term MulOp Primary
Rule 53    MulOp -> *
Rule 54    MulOp -> /
Rule 55    MulOp -> %
Rule 56    Factor -> Primary
Rule 57    Factor -> UnaryOp Primary
Rule 58    UnaryOp -> -
Rule 59    UnaryOp -> !
Rule 60    Primary -> INTLIT
Rule 61    Primary -> FLOATLIT
Rule 62    Primary -> ID
Rule 63    Primary -> ID ( )
Rule 64    Primary -> ID ( Primary )

Terminals, with rules where they appear

!                    : 59
%                    : 55
(                    : 3 4 29 30 31 63 64
)                    : 3 4 29 30 31 63 64
*                    : 53
+                    : 49
-                    : 50 58
/                    : 54
;                    : 8 9 13 26 31 32
<                    : 43
=                    : 32
>                    : 45
AND                  : 36
BOOL                 : 15
CHAR                 : 17
ELSE                 : 29
EQ                   : 39
FLOAT                : 16
FLOATLIT             : 61
FOR                  : 31
GTE                  : 46
ID                   : 3 4 7 13 32 62 63 64
IF                   : 29
INT                  : 14
INTLIT               : 60
LTE                  : 44
NEQ                  : 40
OR                   : 34
RETURN               : 8 9
VOID                 : 19
WHILE                : 30
error                : 
{                    : 3 4 28
}                    : 3 4 28

Nonterminals, with rules where they appear

AddOp                : 48
Addition             : 41 42 42 48
Assignment           : 22 31 31
Block                : 27
Conjunction          : 33 34 36
Declaration          : 11
Declarations         : 3 4 11
EquOp                : 38
Equality             : 35 36
Expression           : 8 29 30 31 32 34
Factor               : 51
ForStatement         : 25
Function             : 1
FunctionReturnType   : 3 4
IfStatement          : 23
MulOp                : 52
Param                : 5
Params               : 4 5
Primary              : 52 56 57 64
Program              : 1 0
RelOp                : 42
Relation             : 37 38 38
ReturnStatement      : 3 4
Statement            : 20 29 29 30 31
Statements           : 3 4 20 28
Term                 : 47 48 52
Type                 : 7 13 18
UnaryOp              : 57
WhileStatement       : 24
empty                : 2 6 12 21

Parsing method: LALR

state 0

    (0) S' -> . Program
    (1) Program -> . Function Program
    (2) Program -> . empty
    (3) Function -> . FunctionReturnType ID ( ) { Declarations Statements ReturnStatement }
    (4) Function -> . FunctionReturnType ID ( Params ) { Declarations Statements ReturnStatement }
    (10) empty -> .
    (18) FunctionReturnType -> . Type
    (19) FunctionReturnType -> . VOID
    (14) Type -> . INT
    (15) Type -> . BOOL
    (16) Type -> . FLOAT
    (17) Type -> . CHAR

    $end            reduce using rule 10 (empty -> .)
    VOID            shift and go to state 6
    INT             shift and go to state 7
    BOOL            shift and go to state 8
    FLOAT           shift and go to state 9
    CHAR            shift and go to state 10

    Program                        shift and go to state 1
    Function                       shift and go to state 2
    empty                          shift and go to state 3
    FunctionReturnType             shift and go to state 4
    Type                           shift and go to state 5

state 1

    (0) S' -> Program .



state 2

    (1) Program -> Function . Program
    (1) Program -> . Function Program
    (2) Program -> . empty
    (3) Function -> . FunctionReturnType ID ( ) { Declarations Statements ReturnStatement }
    (4) Function -> . FunctionReturnType ID ( Params ) { Declarations Statements ReturnStatement }
    (10) empty -> .
    (18) FunctionReturnType -> . Type
    (19) FunctionReturnType -> . VOID
    (14) Type -> . INT
    (15) Type -> . BOOL
    (16) Type -> . FLOAT
    (17) Type -> . CHAR

    $end            reduce using rule 10 (empty -> .)
    VOID            shift and go to state 6
    INT             shift and go to state 7
    BOOL            shift and go to state 8
    FLOAT           shift and go to state 9
    CHAR            shift and go to state 10

    Function                       shift and go to state 2
    Program                        shift and go to state 11
    empty                          shift and go to state 3
    FunctionReturnType             shift and go to state 4
    Type                           shift and go to state 5

state 3

    (2) Program -> empty .

    $end            reduce using rule 2 (Program -> empty .)


state 4

    (3) Function -> FunctionReturnType . ID ( ) { Declarations Statements ReturnStatement }
    (4) Function -> FunctionReturnType . ID ( Params ) { Declarations Statements ReturnStatement }

    ID              shift and go to state 12


state 5

    (18) FunctionReturnType -> Type .

    ID              reduce using rule 18 (FunctionReturnType -> Type .)


state 6

    (19) FunctionReturnType -> VOID .

    ID              reduce using rule 19 (FunctionReturnType -> VOID .)


state 7

    (14) Type -> INT .

    ID              reduce using rule 14 (Type -> INT .)


state 8

    (15) Type -> BOOL .

    ID              reduce using rule 15 (Type -> BOOL .)


state 9

    (16) Type -> FLOAT .

    ID              reduce using rule 16 (Type -> FLOAT .)


state 10

    (17) Type -> CHAR .

    ID              reduce using rule 17 (Type -> CHAR .)


state 11

    (1) Program -> Function Program .

    $end            reduce using rule 1 (Program -> Function Program .)


state 12

    (3) Function -> FunctionReturnType ID . ( ) { Declarations Statements ReturnStatement }
    (4) Function -> FunctionReturnType ID . ( Params ) { Declarations Statements ReturnStatement }

    (               shift and go to state 13


state 13

    (3) Function -> FunctionReturnType ID ( . ) { Declarations Statements ReturnStatement }
    (4) Function -> FunctionReturnType ID ( . Params ) { Declarations Statements ReturnStatement }
    (5) Params -> . Param Params
    (6) Params -> . empty
    (7) Param -> . Type ID
    (10) empty -> .
    (14) Type -> . INT
    (15) Type -> . BOOL
    (16) Type -> . FLOAT
    (17) Type -> . CHAR

  ! shift/reduce conflict for ) resolved as shift
    )               shift and go to state 14
    INT             shift and go to state 7
    BOOL            shift and go to state 8
    FLOAT           shift and go to state 9
    CHAR            shift and go to state 10

  ! )               [ reduce using rule 10 (empty -> .) ]

    Params                         shift and go to state 15
    Param                          shift and go to state 16
    empty                          shift and go to state 17
    Type                           shift and go to state 18

state 14

    (3) Function -> FunctionReturnType ID ( ) . { Declarations Statements ReturnStatement }

    {               shift and go to state 19


state 15

    (4) Function -> FunctionReturnType ID ( Params . ) { Declarations Statements ReturnStatement }

    )               shift and go to state 20


state 16

    (5) Params -> Param . Params
    (5) Params -> . Param Params
    (6) Params -> . empty
    (7) Param -> . Type ID
    (10) empty -> .
    (14) Type -> . INT
    (15) Type -> . BOOL
    (16) Type -> . FLOAT
    (17) Type -> . CHAR

    )               reduce using rule 10 (empty -> .)
    INT             shift and go to state 7
    BOOL            shift and go to state 8
    FLOAT           shift and go to state 9
    CHAR            shift and go to state 10

    Param                          shift and go to state 16
    Params                         shift and go to state 21
    empty                          shift and go to state 17
    Type                           shift and go to state 18

state 17

    (6) Params -> empty .

    )               reduce using rule 6 (Params -> empty .)


state 18

    (7) Param -> Type . ID

    ID              shift and go to state 22


state 19

    (3) Function -> FunctionReturnType ID ( ) { . Declarations Statements ReturnStatement }
    (11) Declarations -> . Declaration Declarations
    (12) Declarations -> . empty
    (13) Declaration -> . Type ID ;
    (10) empty -> .
    (14) Type -> . INT
    (15) Type -> . BOOL
    (16) Type -> . FLOAT
    (17) Type -> . CHAR

    ;               reduce using rule 10 (empty -> .)
    ID              reduce using rule 10 (empty -> .)
    IF              reduce using rule 10 (empty -> .)
    WHILE           reduce using rule 10 (empty -> .)
    FOR             reduce using rule 10 (empty -> .)
    {               reduce using rule 10 (empty -> .)
    RETURN          reduce using rule 10 (empty -> .)
    INT             shift and go to state 7
    BOOL            shift and go to state 8
    FLOAT           shift and go to state 9
    CHAR            shift and go to state 10

    Declarations                   shift and go to state 23
    Declaration                    shift and go to state 24
    empty                          shift and go to state 25
    Type                           shift and go to state 26

state 20

    (4) Function -> FunctionReturnType ID ( Params ) . { Declarations Statements ReturnStatement }

    {               shift and go to state 27


state 21

    (5) Params -> Param Params .

    )               reduce using rule 5 (Params -> Param Params .)


state 22

    (7) Param -> Type ID .

    INT             reduce using rule 7 (Param -> Type ID .)
    BOOL            reduce using rule 7 (Param -> Type ID .)
    FLOAT           reduce using rule 7 (Param -> Type ID .)
    CHAR            reduce using rule 7 (Param -> Type ID .)
    )               reduce using rule 7 (Param -> Type ID .)


state 23

    (3) Function -> FunctionReturnType ID ( ) { Declarations . Statements ReturnStatement }
    (20) Statements -> . Statement Statements
    (21) Statements -> . empty
    (22) Statement -> . Assignment
    (23) Statement -> . IfStatement
    (24) Statement -> . WhileStatement
    (25) Statement -> . ForStatement
    (26) Statement -> . ;
    (27) Statement -> . Block
    (10) empty -> .
    (32) Assignment -> . ID = Expression ;
    (29) IfStatement -> . IF ( Expression ) Statement ELSE Statement
    (30) WhileStatement -> . WHILE ( Expression ) Statement
    (31) ForStatement -> . FOR ( Assignment Expression ; Assignment ) Statement
    (28) Block -> . { Statements }

    ;               shift and go to state 37
    RETURN          reduce using rule 10 (empty -> .)
    ID              shift and go to state 28
    IF              shift and go to state 39
    WHILE           shift and go to state 40
    FOR             shift and go to state 41
    {               shift and go to state 29

    Statements                     shift and go to state 30
    Statement                      shift and go to state 31
    empty                          shift and go to state 32
    Assignment                     shift and go to state 33
    IfStatement                    shift and go to state 34
    WhileStatement                 shift and go to state 35
    ForStatement                   shift and go to state 36
    Block                          shift and go to state 38

state 24

    (11) Declarations -> Declaration . Declarations
    (11) Declarations -> . Declaration Declarations
    (12) Declarations -> . empty
    (13) Declaration -> . Type ID ;
    (10) empty -> .
    (14) Type -> . INT
    (15) Type -> . BOOL
    (16) Type -> . FLOAT
    (17) Type -> . CHAR

    ;               reduce using rule 10 (empty -> .)
    ID              reduce using rule 10 (empty -> .)
    IF              reduce using rule 10 (empty -> .)
    WHILE           reduce using rule 10 (empty -> .)
    FOR             reduce using rule 10 (empty -> .)
    {               reduce using rule 10 (empty -> .)
    RETURN          reduce using rule 10 (empty -> .)
    INT             shift and go to state 7
    BOOL            shift and go to state 8
    FLOAT           shift and go to state 9
    CHAR            shift and go to state 10

    Declaration                    shift and go to state 24
    Declarations                   shift and go to state 42
    empty                          shift and go to state 25
    Type                           shift and go to state 26

state 25

    (12) Declarations -> empty .

    ;               reduce using rule 12 (Declarations -> empty .)
    ID              reduce using rule 12 (Declarations -> empty .)
    IF              reduce using rule 12 (Declarations -> empty .)
    WHILE           reduce using rule 12 (Declarations -> empty .)
    FOR             reduce using rule 12 (Declarations -> empty .)
    {               reduce using rule 12 (Declarations -> empty .)
    RETURN          reduce using rule 12 (Declarations -> empty .)


state 26

    (13) Declaration -> Type . ID ;

    ID              shift and go to state 43


state 27

    (4) Function -> FunctionReturnType ID ( Params ) { . Declarations Statements ReturnStatement }
    (11) Declarations -> . Declaration Declarations
    (12) Declarations -> . empty
    (13) Declaration -> . Type ID ;
    (10) empty -> .
    (14) Type -> . INT
    (15) Type -> . BOOL
    (16) Type -> . FLOAT
    (17) Type -> . CHAR

    ;               reduce using rule 10 (empty -> .)
    ID              reduce using rule 10 (empty -> .)
    IF              reduce using rule 10 (empty -> .)
    WHILE           reduce using rule 10 (empty -> .)
    FOR             reduce using rule 10 (empty -> .)
    {               reduce using rule 10 (empty -> .)
    RETURN          reduce using rule 10 (empty -> .)
    INT             shift and go to state 7
    BOOL            shift and go to state 8
    FLOAT           shift and go to state 9
    CHAR            shift and go to state 10

    Declarations                   shift and go to state 44
    Declaration                    shift and go to state 24
    empty                          shift and go to state 25
    Type                           shift and go to state 26

state 28

    (32) Assignment -> ID . = Expression ;

    =               shift and go to state 45


state 29

    (28) Block -> { . Statements }
    (20) Statements -> . Statement Statements
    (21) Statements -> . empty
    (22) Statement -> . Assignment
    (23) Statement -> . IfStatement
    (24) Statement -> . WhileStatement
    (25) Statement -> . ForStatement
    (26) Statement -> . ;
    (27) Statement -> . Block
    (10) empty -> .
    (32) Assignment -> . ID = Expression ;
    (29) IfStatement -> . IF ( Expression ) Statement ELSE Statement
    (30) WhileStatement -> . WHILE ( Expression ) Statement
    (31) ForStatement -> . FOR ( Assignment Expression ; Assignment ) Statement
    (28) Block -> . { Statements }

    ;               shift and go to state 37
    }               reduce using rule 10 (empty -> .)
    ID              shift and go to state 28
    IF              shift and go to state 39
    WHILE           shift and go to state 40
    FOR             shift and go to state 41
    {               shift and go to state 29

    Statements                     shift and go to state 46
    Statement                      shift and go to state 31
    empty                          shift and go to state 32
    Assignment                     shift and go to state 33
    IfStatement                    shift and go to state 34
    WhileStatement                 shift and go to state 35
    ForStatement                   shift and go to state 36
    Block                          shift and go to state 38

state 30

    (3) Function -> FunctionReturnType ID ( ) { Declarations Statements . ReturnStatement }
    (8) ReturnStatement -> . RETURN Expression ;
    (9) ReturnStatement -> . RETURN ;

    RETURN          shift and go to state 48

    ReturnStatement                shift and go to state 47

state 31

    (20) Statements -> Statement . Statements
    (20) Statements -> . Statement Statements
    (21) Statements -> . empty
    (22) Statement -> . Assignment
    (23) Statement -> . IfStatement
    (24) Statement -> . WhileStatement
    (25) Statement -> . ForStatement
    (26) Statement -> . ;
    (27) Statement -> . Block
    (10) empty -> .
    (32) Assignment -> . ID = Expression ;
    (29) IfStatement -> . IF ( Expression ) Statement ELSE Statement
    (30) WhileStatement -> . WHILE ( Expression ) Statement
    (31) ForStatement -> . FOR ( Assignment Expression ; Assignment ) Statement
    (28) Block -> . { Statements }

    ;               shift and go to state 37
    RETURN          reduce using rule 10 (empty -> .)
    }               reduce using rule 10 (empty -> .)
    ID              shift and go to state 28
    IF              shift and go to state 39
    WHILE           shift and go to state 40
    FOR             shift and go to state 41
    {               shift and go to state 29

    Statement                      shift and go to state 31
    Statements                     shift and go to state 49
    empty                          shift and go to state 32
    Assignment                     shift and go to state 33
    IfStatement                    shift and go to state 34
    WhileStatement                 shift and go to state 35
    ForStatement                   shift and go to state 36
    Block                          shift and go to state 38

state 32

    (21) Statements -> empty .

    RETURN          reduce using rule 21 (Statements -> empty .)
    }               reduce using rule 21 (Statements -> empty .)


state 33

    (22) Statement -> Assignment .

    ;               reduce using rule 22 (Statement -> Assignment .)
    ID              reduce using rule 22 (Statement -> Assignment .)
    IF              reduce using rule 22 (Statement -> Assignment .)
    WHILE           reduce using rule 22 (Statement -> Assignment .)
    FOR             reduce using rule 22 (Statement -> Assignment .)
    {               reduce using rule 22 (Statement -> Assignment .)
    RETURN          reduce using rule 22 (Statement -> Assignment .)
    }               reduce using rule 22 (Statement -> Assignment .)
    ELSE            reduce using rule 22 (Statement -> Assignment .)


state 34

    (23) Statement -> IfStatement .

    ;               reduce using rule 23 (Statement -> IfStatement .)
    ID              reduce using rule 23 (Statement -> IfStatement .)
    IF              reduce using rule 23 (Statement -> IfStatement .)
    WHILE           reduce using rule 23 (Statement -> IfStatement .)
    FOR             reduce using rule 23 (Statement -> IfStatement .)
    {               reduce using rule 23 (Statement -> IfStatement .)
    RETURN          reduce using rule 23 (Statement -> IfStatement .)
    }               reduce using rule 23 (Statement -> IfStatement .)
    ELSE            reduce using rule 23 (Statement -> IfStatement .)


state 35

    (24) Statement -> WhileStatement .

    ;               reduce using rule 24 (Statement -> WhileStatement .)
    ID              reduce using rule 24 (Statement -> WhileStatement .)
    IF              reduce using rule 24 (Statement -> WhileStatement .)
    WHILE           reduce using rule 24 (Statement -> WhileStatement .)
    FOR             reduce using rule 24 (Statement -> WhileStatement .)
    {               reduce using rule 24 (Statement -> WhileStatement .)
    RETURN          reduce using rule 24 (Statement -> WhileStatement .)
    }               reduce using rule 24 (Statement -> WhileStatement .)
    ELSE            reduce using rule 24 (Statement -> WhileStatement .)


state 36

    (25) Statement -> ForStatement .

    ;               reduce using rule 25 (Statement -> ForStatement .)
    ID              reduce using rule 25 (Statement -> ForStatement .)
    IF              reduce using rule 25 (Statement -> ForStatement .)
    WHILE           reduce using rule 25 (Statement -> ForStatement .)
    FOR             reduce using rule 25 (Statement -> ForStatement .)
    {               reduce using rule 25 (Statement -> ForStatement .)
    RETURN          reduce using rule 25 (Statement -> ForStatement .)
    }               reduce using rule 25 (Statement -> ForStatement .)
    ELSE            reduce using rule 25 (Statement -> ForStatement .)


state 37

    (26) Statement -> ; .

    ;               reduce using rule 26 (Statement -> ; .)
    ID              reduce using rule 26 (Statement -> ; .)
    IF              reduce using rule 26 (Statement -> ; .)
    WHILE           reduce using rule 26 (Statement -> ; .)
    FOR             reduce using rule 26 (Statement -> ; .)
    {               reduce using rule 26 (Statement -> ; .)
    RETURN          reduce using rule 26 (Statement -> ; .)
    }               reduce using rule 26 (Statement -> ; .)
    ELSE            reduce using rule 26 (Statement -> ; .)


state 38

    (27) Statement -> Block .

    ;               reduce using rule 27 (Statement -> Block .)
    ID              reduce using rule 27 (Statement -> Block .)
    IF              reduce using rule 27 (Statement -> Block .)
    WHILE           reduce using rule 27 (Statement -> Block .)
    FOR             reduce using rule 27 (Statement -> Block .)
    {               reduce using rule 27 (Statement -> Block .)
    RETURN          reduce using rule 27 (Statement -> Block .)
    }               reduce using rule 27 (Statement -> Block .)
    ELSE            reduce using rule 27 (Statement -> Block .)


state 39

    (29) IfStatement -> IF . ( Expression ) Statement ELSE Statement

    (               shift and go to state 50


state 40

    (30) WhileStatement -> WHILE . ( Expression ) Statement

    (               shift and go to state 51


state 41

    (31) ForStatement -> FOR . ( Assignment Expression ; Assignment ) Statement

    (               shift and go to state 52


state 42

    (11) Declarations -> Declaration Declarations .

    ;               reduce using rule 11 (Declarations -> Declaration Declarations .)
    ID              reduce using rule 11 (Declarations -> Declaration Declarations .)
    IF              reduce using rule 11 (Declarations -> Declaration Declarations .)
    WHILE           reduce using rule 11 (Declarations -> Declaration Declarations .)
    FOR             reduce using rule 11 (Declarations -> Declaration Declarations .)
    {               reduce using rule 11 (Declarations -> Declaration Declarations .)
    RETURN          reduce using rule 11 (Declarations -> Declaration Declarations .)


state 43

    (13) Declaration -> Type ID . ;

    ;               shift and go to state 53


state 44

    (4) Function -> FunctionReturnType ID ( Params ) { Declarations . Statements ReturnStatement }
    (20) Statements -> . Statement Statements
    (21) Statements -> . empty
    (22) Statement -> . Assignment
    (23) Statement -> . IfStatement
    (24) Statement -> . WhileStatement
    (25) Statement -> . ForStatement
    (26) Statement -> . ;
    (27) Statement -> . Block
    (10) empty -> .
    (32) Assignment -> . ID = Expression ;
    (29) IfStatement -> . IF ( Expression ) Statement ELSE Statement
    (30) WhileStatement -> . WHILE ( Expression ) Statement
    (31) ForStatement -> . FOR ( Assignment Expression ; Assignment ) Statement
    (28) Block -> . { Statements }

    ;               shift and go to state 37
    RETURN          reduce using rule 10 (empty -> .)
    ID              shift and go to state 28
    IF              shift and go to state 39
    WHILE           shift and go to state 40
    FOR             shift and go to state 41
    {               shift and go to state 29

    Statements                     shift and go to state 54
    Statement                      shift and go to state 31
    empty                          shift and go to state 32
    Assignment                     shift and go to state 33
    IfStatement                    shift and go to state 34
    WhileStatement                 shift and go to state 35
    ForStatement                   shift and go to state 36
    Block                          shift and go to state 38

state 45

    (32) Assignment -> ID = . Expression ;
    (33) Expression -> . Conjunction
    (34) Expression -> . Expression OR Conjunction
    (35) Conjunction -> . Equality
    (36) Conjunction -> . Conjunction AND Equality
    (37) Equality -> . Relation
    (38) Equality -> . Relation EquOp Relation
    (41) Relation -> . Addition
    (42) Relation -> . Addition RelOp Addition
    (47) Addition -> . Term
    (48) Addition -> . Addition AddOp Term
    (51) Term -> . Factor
    (52) Term -> . Term MulOp Primary
    (56) Factor -> . Primary
    (57) Factor -> . UnaryOp Primary
    (60) Primary -> . INTLIT
    (61) Primary -> . FLOATLIT
    (62) Primary -> . ID
    (63) Primary -> . ID ( )
    (64) Primary -> . ID ( Primary )
    (58) UnaryOp -> . -
    (59) UnaryOp -> . !

    INTLIT          shift and go to state 65
    FLOATLIT        shift and go to state 66
    ID              shift and go to state 55
    -               shift and go to state 67
    !               shift and go to state 68

    Expression                     shift and go to state 56
    Conjunction                    shift and go to state 57
    Equality                       shift and go to state 58
    Relation                       shift and go to state 59
    Addition                       shift and go to state 60
    Term                           shift and go to state 61
    Factor                         shift and go to state 62
    Primary                        shift and go to state 63
    UnaryOp                        shift and go to state 64

state 46

    (28) Block -> { Statements . }

    }               shift and go to state 69


state 47

    (3) Function -> FunctionReturnType ID ( ) { Declarations Statements ReturnStatement . }

    }               shift and go to state 70


state 48

    (8) ReturnStatement -> RETURN . Expression ;
    (9) ReturnStatement -> RETURN . ;
    (33) Expression -> . Conjunction
    (34) Expression -> . Expression OR Conjunction
    (35) Conjunction -> . Equality
    (36) Conjunction -> . Conjunction AND Equality
    (37) Equality -> . Relation
    (38) Equality -> . Relation EquOp Relation
    (41) Relation -> . Addition
    (42) Relation -> . Addition RelOp Addition
    (47) Addition -> . Term
    (48) Addition -> . Addition AddOp Term
    (51) Term -> . Factor
    (52) Term -> . Term MulOp Primary
    (56) Factor -> . Primary
    (57) Factor -> . UnaryOp Primary
    (60) Primary -> . INTLIT
    (61) Primary -> . FLOATLIT
    (62) Primary -> . ID
    (63) Primary -> . ID ( )
    (64) Primary -> . ID ( Primary )
    (58) UnaryOp -> . -
    (59) UnaryOp -> . !

    ;               shift and go to state 72
    INTLIT          shift and go to state 65
    FLOATLIT        shift and go to state 66
    ID              shift and go to state 55
    -               shift and go to state 67
    !               shift and go to state 68

    Expression                     shift and go to state 71
    Conjunction                    shift and go to state 57
    Equality                       shift and go to state 58
    Relation                       shift and go to state 59
    Addition                       shift and go to state 60
    Term                           shift and go to state 61
    Factor                         shift and go to state 62
    Primary                        shift and go to state 63
    UnaryOp                        shift and go to state 64

state 49

    (20) Statements -> Statement Statements .

    RETURN          reduce using rule 20 (Statements -> Statement Statements .)
    }               reduce using rule 20 (Statements -> Statement Statements .)


state 50

    (29) IfStatement -> IF ( . Expression ) Statement ELSE Statement
    (33) Expression -> . Conjunction
    (34) Expression -> . Expression OR Conjunction
    (35) Conjunction -> . Equality
    (36) Conjunction -> . Conjunction AND Equality
    (37) Equality -> . Relation
    (38) Equality -> . Relation EquOp Relation
    (41) Relation -> . Addition
    (42) Relation -> . Addition RelOp Addition
    (47) Addition -> . Term
    (48) Addition -> . Addition AddOp Term
    (51) Term -> . Factor
    (52) Term -> . Term MulOp Primary
    (56) Factor -> . Primary
    (57) Factor -> . UnaryOp Primary
    (60) Primary -> . INTLIT
    (61) Primary -> . FLOATLIT
    (62) Primary -> . ID
    (63) Primary -> . ID ( )
    (64) Primary -> . ID ( Primary )
    (58) UnaryOp -> . -
    (59) UnaryOp -> . !

    INTLIT          shift and go to state 65
    FLOATLIT        shift and go to state 66
    ID              shift and go to state 55
    -               shift and go to state 67
    !               shift and go to state 68

    Expression                     shift and go to state 73
    Conjunction                    shift and go to state 57
    Equality                       shift and go to state 58
    Relation                       shift and go to state 59
    Addition                       shift and go to state 60
    Term                           shift and go to state 61
    Factor                         shift and go to state 62
    Primary                        shift and go to state 63
    UnaryOp                        shift and go to state 64

state 51

    (30) WhileStatement -> WHILE ( . Expression ) Statement
    (33) Expression -> . Conjunction
    (34) Expression -> . Expression OR Conjunction
    (35) Conjunction -> . Equality
    (36) Conjunction -> . Conjunction AND Equality
    (37) Equality -> . Relation
    (38) Equality -> . Relation EquOp Relation
    (41) Relation -> . Addition
    (42) Relation -> . Addition RelOp Addition
    (47) Addition -> . Term
    (48) Addition -> . Addition AddOp Term
    (51) Term -> . Factor
    (52) Term -> . Term MulOp Primary
    (56) Factor -> . Primary
    (57) Factor -> . UnaryOp Primary
    (60) Primary -> . INTLIT
    (61) Primary -> . FLOATLIT
    (62) Primary -> . ID
    (63) Primary -> . ID ( )
    (64) Primary -> . ID ( Primary )
    (58) UnaryOp -> . -
    (59) UnaryOp -> . !

    INTLIT          shift and go to state 65
    FLOATLIT        shift and go to state 66
    ID              shift and go to state 55
    -               shift and go to state 67
    !               shift and go to state 68

    Expression                     shift and go to state 74
    Conjunction                    shift and go to state 57
    Equality                       shift and go to state 58
    Relation                       shift and go to state 59
    Addition                       shift and go to state 60
    Term                           shift and go to state 61
    Factor                         shift and go to state 62
    Primary                        shift and go to state 63
    UnaryOp                        shift and go to state 64

state 52

    (31) ForStatement -> FOR ( . Assignment Expression ; Assignment ) Statement
    (32) Assignment -> . ID = Expression ;

    ID              shift and go to state 28

    Assignment                     shift and go to state 75

state 53

    (13) Declaration -> Type ID ; .

    INT             reduce using rule 13 (Declaration -> Type ID ; .)
    BOOL            reduce using rule 13 (Declaration -> Type ID ; .)
    FLOAT           reduce using rule 13 (Declaration -> Type ID ; .)
    CHAR            reduce using rule 13 (Declaration -> Type ID ; .)
    ;               reduce using rule 13 (Declaration -> Type ID ; .)
    ID              reduce using rule 13 (Declaration -> Type ID ; .)
    IF              reduce using rule 13 (Declaration -> Type ID ; .)
    WHILE           reduce using rule 13 (Declaration -> Type ID ; .)
    FOR             reduce using rule 13 (Declaration -> Type ID ; .)
    {               reduce using rule 13 (Declaration -> Type ID ; .)
    RETURN          reduce using rule 13 (Declaration -> Type ID ; .)


state 54

    (4) Function -> FunctionReturnType ID ( Params ) { Declarations Statements . ReturnStatement }
    (8) ReturnStatement -> . RETURN Expression ;
    (9) ReturnStatement -> . RETURN ;

    RETURN          shift and go to state 48

    ReturnStatement                shift and go to state 76

state 55

    (62) Primary -> ID .
    (63) Primary -> ID . ( )
    (64) Primary -> ID . ( Primary )

    *               reduce using rule 62 (Primary -> ID .)
    /               reduce using rule 62 (Primary -> ID .)
    %               reduce using rule 62 (Primary -> ID .)
    <               reduce using rule 62 (Primary -> ID .)
    LTE             reduce using rule 62 (Primary -> ID .)
    >               reduce using rule 62 (Primary -> ID .)
    GTE             reduce using rule 62 (Primary -> ID .)
    +               reduce using rule 62 (Primary -> ID .)
    -               reduce using rule 62 (Primary -> ID .)
    EQ              reduce using rule 62 (Primary -> ID .)
    NEQ             reduce using rule 62 (Primary -> ID .)
    AND             reduce using rule 62 (Primary -> ID .)
    ;               reduce using rule 62 (Primary -> ID .)
    OR              reduce using rule 62 (Primary -> ID .)
    )               reduce using rule 62 (Primary -> ID .)
    (               shift and go to state 77


state 56

    (32) Assignment -> ID = Expression . ;
    (34) Expression -> Expression . OR Conjunction

    ;               shift and go to state 78
    OR              shift and go to state 79


state 57

    (33) Expression -> Conjunction .
    (36) Conjunction -> Conjunction . AND Equality

    ;               reduce using rule 33 (Expression -> Conjunction .)
    OR              reduce using rule 33 (Expression -> Conjunction .)
    )               reduce using rule 33 (Expression -> Conjunction .)
    AND             shift and go to state 80


state 58

    (35) Conjunction -> Equality .

    AND             reduce using rule 35 (Conjunction -> Equality .)
    ;               reduce using rule 35 (Conjunction -> Equality .)
    OR              reduce using rule 35 (Conjunction -> Equality .)
    )               reduce using rule 35 (Conjunction -> Equality .)


state 59

    (37) Equality -> Relation .
    (38) Equality -> Relation . EquOp Relation
    (39) EquOp -> . EQ
    (40) EquOp -> . NEQ

    AND             reduce using rule 37 (Equality -> Relation .)
    ;               reduce using rule 37 (Equality -> Relation .)
    OR              reduce using rule 37 (Equality -> Relation .)
    )               reduce using rule 37 (Equality -> Relation .)
    EQ              shift and go to state 82
    NEQ             shift and go to state 83

    EquOp                          shift and go to state 81

state 60

    (41) Relation -> Addition .
    (42) Relation -> Addition . RelOp Addition
    (48) Addition -> Addition . AddOp Term
    (43) RelOp -> . <
    (44) RelOp -> . LTE
    (45) RelOp -> . >
    (46) RelOp -> . GTE
    (49) AddOp -> . +
    (50) AddOp -> . -

    EQ              reduce using rule 41 (Relation -> Addition .)
    NEQ             reduce using rule 41 (Relation -> Addition .)
    AND             reduce using rule 41 (Relation -> Addition .)
    ;               reduce using rule 41 (Relation -> Addition .)
    OR              reduce using rule 41 (Relation -> Addition .)
    )               reduce using rule 41 (Relation -> Addition .)
    <               shift and go to state 86
    LTE             shift and go to state 87
    >               shift and go to state 88
    GTE             shift and go to state 89
    +               shift and go to state 90
    -               shift and go to state 91

    RelOp                          shift and go to state 84
    AddOp                          shift and go to state 85

state 61

    (47) Addition -> Term .
    (52) Term -> Term . MulOp Primary
    (53) MulOp -> . *
    (54) MulOp -> . /
    (55) MulOp -> . %

    <               reduce using rule 47 (Addition -> Term .)
    LTE             reduce using rule 47 (Addition -> Term .)
    >               reduce using rule 47 (Addition -> Term .)
    GTE             reduce using rule 47 (Addition -> Term .)
    +               reduce using rule 47 (Addition -> Term .)
    -               reduce using rule 47 (Addition -> Term .)
    EQ              reduce using rule 47 (Addition -> Term .)
    NEQ             reduce using rule 47 (Addition -> Term .)
    AND             reduce using rule 47 (Addition -> Term .)
    ;               reduce using rule 47 (Addition -> Term .)
    OR              reduce using rule 47 (Addition -> Term .)
    )               reduce using rule 47 (Addition -> Term .)
    *               shift and go to state 93
    /               shift and go to state 94
    %               shift and go to state 95

    MulOp                          shift and go to state 92

state 62

    (51) Term -> Factor .

    *               reduce using rule 51 (Term -> Factor .)
    /               reduce using rule 51 (Term -> Factor .)
    %               reduce using rule 51 (Term -> Factor .)
    <               reduce using rule 51 (Term -> Factor .)
    LTE             reduce using rule 51 (Term -> Factor .)
    >               reduce using rule 51 (Term -> Factor .)
    GTE             reduce using rule 51 (Term -> Factor .)
    +               reduce using rule 51 (Term -> Factor .)
    -               reduce using rule 51 (Term -> Factor .)
    EQ              reduce using rule 51 (Term -> Factor .)
    NEQ             reduce using rule 51 (Term -> Factor .)
    AND             reduce using rule 51 (Term -> Factor .)
    ;               reduce using rule 51 (Term -> Factor .)
    OR              reduce using rule 51 (Term -> Factor .)
    )               reduce using rule 51 (Term -> Factor .)


state 63

    (56) Factor -> Primary .

    *               reduce using rule 56 (Factor -> Primary .)
    /               reduce using rule 56 (Factor -> Primary .)
    %               reduce using rule 56 (Factor -> Primary .)
    <               reduce using rule 56 (Factor -> Primary .)
    LTE             reduce using rule 56 (Factor -> Primary .)
    >               reduce using rule 56 (Factor -> Primary .)
    GTE             reduce using rule 56 (Factor -> Primary .)
    +               reduce using rule 56 (Factor -> Primary .)
    -               reduce using rule 56 (Factor -> Primary .)
    EQ              reduce using rule 56 (Factor -> Primary .)
    NEQ             reduce using rule 56 (Factor -> Primary .)
    AND             reduce using rule 56 (Factor -> Primary .)
    ;               reduce using rule 56 (Factor -> Primary .)
    OR              reduce using rule 56 (Factor -> Primary .)
    )               reduce using rule 56 (Factor -> Primary .)


state 64

    (57) Factor -> UnaryOp . Primary
    (60) Primary -> . INTLIT
    (61) Primary -> . FLOATLIT
    (62) Primary -> . ID
    (63) Primary -> . ID ( )
    (64) Primary -> . ID ( Primary )

    INTLIT          shift and go to state 65
    FLOATLIT        shift and go to state 66
    ID              shift and go to state 55

    Primary                        shift and go to state 96

state 65

    (60) Primary -> INTLIT .

    *               reduce using rule 60 (Primary -> INTLIT .)
    /               reduce using rule 60 (Primary -> INTLIT .)
    %               reduce using rule 60 (Primary -> INTLIT .)
    <               reduce using rule 60 (Primary -> INTLIT .)
    LTE             reduce using rule 60 (Primary -> INTLIT .)
    >               reduce using rule 60 (Primary -> INTLIT .)
    GTE             reduce using rule 60 (Primary -> INTLIT .)
    +               reduce using rule 60 (Primary -> INTLIT .)
    -               reduce using rule 60 (Primary -> INTLIT .)
    EQ              reduce using rule 60 (Primary -> INTLIT .)
    NEQ             reduce using rule 60 (Primary -> INTLIT .)
    AND             reduce using rule 60 (Primary -> INTLIT .)
    ;               reduce using rule 60 (Primary -> INTLIT .)
    OR              reduce using rule 60 (Primary -> INTLIT .)
    )               reduce using rule 60 (Primary -> INTLIT .)


state 66

    (61) Primary -> FLOATLIT .

    *               reduce using rule 61 (Primary -> FLOATLIT .)
    /               reduce using rule 61 (Primary -> FLOATLIT .)
    %               reduce using rule 61 (Primary -> FLOATLIT .)
    <               reduce using rule 61 (Primary -> FLOATLIT .)
    LTE             reduce using rule 61 (Primary -> FLOATLIT .)
    >               reduce using rule 61 (Primary -> FLOATLIT .)
    GTE             reduce using rule 61 (Primary -> FLOATLIT .)
    +               reduce using rule 61 (Primary -> FLOATLIT .)
    -               reduce using rule 61 (Primary -> FLOATLIT .)
    EQ              reduce using rule 61 (Primary -> FLOATLIT .)
    NEQ             reduce using rule 61 (Primary -> FLOATLIT .)
    AND             reduce using rule 61 (Primary -> FLOATLIT .)
    ;               reduce using rule 61 (Primary -> FLOATLIT .)
    OR              reduce using rule 61 (Primary -> FLOATLIT .)
    )               reduce using rule 61 (Primary -> FLOATLIT .)


state 67

    (58) UnaryOp -> - .

    INTLIT          reduce using rule 58 (UnaryOp -> - .)
    FLOATLIT        reduce using rule 58 (UnaryOp -> - .)
    ID              reduce using rule 58 (UnaryOp -> - .)


state 68

    (59) UnaryOp -> ! .

    INTLIT          reduce using rule 59 (UnaryOp -> ! .)
    FLOATLIT        reduce using rule 59 (UnaryOp -> ! .)
    ID              reduce using rule 59 (UnaryOp -> ! .)


state 69

    (28) Block -> { Statements } .

    ;               reduce using rule 28 (Block -> { Statements } .)
    ID              reduce using rule 28 (Block -> { Statements } .)
    IF              reduce using rule 28 (Block -> { Statements } .)
    WHILE           reduce using rule 28 (Block -> { Statements } .)
    FOR             reduce using rule 28 (Block -> { Statements } .)
    {               reduce using rule 28 (Block -> { Statements } .)
    RETURN          reduce using rule 28 (Block -> { Statements } .)
    }               reduce using rule 28 (Block -> { Statements } .)
    ELSE            reduce using rule 28 (Block -> { Statements } .)


state 70

    (3) Function -> FunctionReturnType ID ( ) { Declarations Statements ReturnStatement } .

    VOID            reduce using rule 3 (Function -> FunctionReturnType ID ( ) { Declarations Statements ReturnStatement } .)
    INT             reduce using rule 3 (Function -> FunctionReturnType ID ( ) { Declarations Statements ReturnStatement } .)
    BOOL            reduce using rule 3 (Function -> FunctionReturnType ID ( ) { Declarations Statements ReturnStatement } .)
    FLOAT           reduce using rule 3 (Function -> FunctionReturnType ID ( ) { Declarations Statements ReturnStatement } .)
    CHAR            reduce using rule 3 (Function -> FunctionReturnType ID ( ) { Declarations Statements ReturnStatement } .)
    $end            reduce using rule 3 (Function -> FunctionReturnType ID ( ) { Declarations Statements ReturnStatement } .)


state 71

    (8) ReturnStatement -> RETURN Expression . ;
    (34) Expression -> Expression . OR Conjunction

    ;               shift and go to state 97
    OR              shift and go to state 79


state 72

    (9) ReturnStatement -> RETURN ; .

    }               reduce using rule 9 (ReturnStatement -> RETURN ; .)


state 73

    (29) IfStatement -> IF ( Expression . ) Statement ELSE Statement
    (34) Expression -> Expression . OR Conjunction

    )               shift and go to state 98
    OR              shift and go to state 79


state 74

    (30) WhileStatement -> WHILE ( Expression . ) Statement
    (34) Expression -> Expression . OR Conjunction

    )               shift and go to state 99
    OR              shift and go to state 79


state 75

    (31) ForStatement -> FOR ( Assignment . Expression ; Assignment ) Statement
    (33) Expression -> . Conjunction
    (34) Expression -> . Expression OR Conjunction
    (35) Conjunction -> . Equality
    (36) Conjunction -> . Conjunction AND Equality
    (37) Equality -> . Relation
    (38) Equality -> . Relation EquOp Relation
    (41) Relation -> . Addition
    (42) Relation -> . Addition RelOp Addition
    (47) Addition -> . Term
    (48) Addition -> . Addition AddOp Term
    (51) Term -> . Factor
    (52) Term -> . Term MulOp Primary
    (56) Factor -> . Primary
    (57) Factor -> . UnaryOp Primary
    (60) Primary -> . INTLIT
    (61) Primary -> . FLOATLIT
    (62) Primary -> . ID
    (63) Primary -> . ID ( )
    (64) Primary -> . ID ( Primary )
    (58) UnaryOp -> . -
    (59) UnaryOp -> . !

    INTLIT          shift and go to state 65
    FLOATLIT        shift and go to state 66
    ID              shift and go to state 55
    -               shift and go to state 67
    !               shift and go to state 68

    Expression                     shift and go to state 100
    Conjunction                    shift and go to state 57
    Equality                       shift and go to state 58
    Relation                       shift and go to state 59
    Addition                       shift and go to state 60
    Term                           shift and go to state 61
    Factor                         shift and go to state 62
    Primary                        shift and go to state 63
    UnaryOp                        shift and go to state 64

state 76

    (4) Function -> FunctionReturnType ID ( Params ) { Declarations Statements ReturnStatement . }

    }               shift and go to state 101


state 77

    (63) Primary -> ID ( . )
    (64) Primary -> ID ( . Primary )
    (60) Primary -> . INTLIT
    (61) Primary -> . FLOATLIT
    (62) Primary -> . ID
    (63) Primary -> . ID ( )
    (64) Primary -> . ID ( Primary )

    )               shift and go to state 102
    INTLIT          shift and go to state 65
    FLOATLIT        shift and go to state 66
    ID              shift and go to state 55

    Primary                        shift and go to state 103

state 78

    (32) Assignment -> ID = Expression ; .

    ;               reduce using rule 32 (Assignment -> ID = Expression ; .)
    ID              reduce using rule 32 (Assignment -> ID = Expression ; .)
    IF              reduce using rule 32 (Assignment -> ID = Expression ; .)
    WHILE           reduce using rule 32 (Assignment -> ID = Expression ; .)
    FOR             reduce using rule 32 (Assignment -> ID = Expression ; .)
    {               reduce using rule 32 (Assignment -> ID = Expression ; .)
    RETURN          reduce using rule 32 (Assignment -> ID = Expression ; .)
    }               reduce using rule 32 (Assignment -> ID = Expression ; .)
    INTLIT          reduce using rule 32 (Assignment -> ID = Expression ; .)
    FLOATLIT        reduce using rule 32 (Assignment -> ID = Expression ; .)
    -               reduce using rule 32 (Assignment -> ID = Expression ; .)
    !               reduce using rule 32 (Assignment -> ID = Expression ; .)
    ELSE            reduce using rule 32 (Assignment -> ID = Expression ; .)
    )               reduce using rule 32 (Assignment -> ID = Expression ; .)


state 79

    (34) Expression -> Expression OR . Conjunction
    (35) Conjunction -> . Equality
    (36) Conjunction -> . Conjunction AND Equality
    (37) Equality -> . Relation
    (38) Equality -> . Relation EquOp Relation
    (41) Relation -> . Addition
    (42) Relation -> . Addition RelOp Addition
    (47) Addition -> . Term
    (48) Addition -> . Addition AddOp Term
    (51) Term -> . Factor
    (52) Term -> . Term MulOp Primary
    (56) Factor -> . Primary
    (57) Factor -> . UnaryOp Primary
    (60) Primary -> . INTLIT
    (61) Primary -> . FLOATLIT
    (62) Primary -> . ID
    (63) Primary -> . ID ( )
    (64) Primary -> . ID ( Primary )
    (58) UnaryOp -> . -
    (59) UnaryOp -> . !

    INTLIT          shift and go to state 65
    FLOATLIT        shift and go to state 66
    ID              shift and go to state 55
    -               shift and go to state 67
    !               shift and go to state 68

    Conjunction                    shift and go to state 104
    Equality                       shift and go to state 58
    Relation                       shift and go to state 59
    Addition                       shift and go to state 60
    Term                           shift and go to state 61
    Factor                         shift and go to state 62
    Primary                        shift and go to state 63
    UnaryOp                        shift and go to state 64

state 80

    (36) Conjunction -> Conjunction AND . Equality
    (37) Equality -> . Relation
    (38) Equality -> . Relation EquOp Relation
    (41) Relation -> . Addition
    (42) Relation -> . Addition RelOp Addition
    (47) Addition -> . Term
    (48) Addition -> . Addition AddOp Term
    (51) Term -> . Factor
    (52) Term -> . Term MulOp Primary
    (56) Factor -> . Primary
    (57) Factor -> . UnaryOp Primary
    (60) Primary -> . INTLIT
    (61) Primary -> . FLOATLIT
    (62) Primary -> . ID
    (63) Primary -> . ID ( )
    (64) Primary -> . ID ( Primary )
    (58) UnaryOp -> . -
    (59) UnaryOp -> . !

    INTLIT          shift and go to state 65
    FLOATLIT        shift and go to state 66
    ID              shift and go to state 55
    -               shift and go to state 67
    !               shift and go to state 68

    Equality                       shift and go to state 105
    Relation                       shift and go to state 59
    Addition                       shift and go to state 60
    Term                           shift and go to state 61
    Factor                         shift and go to state 62
    Primary                        shift and go to state 63
    UnaryOp                        shift and go to state 64

state 81

    (38) Equality -> Relation EquOp . Relation
    (41) Relation -> . Addition
    (42) Relation -> . Addition RelOp Addition
    (47) Addition -> . Term
    (48) Addition -> . Addition AddOp Term
    (51) Term -> . Factor
    (52) Term -> . Term MulOp Primary
    (56) Factor -> . Primary
    (57) Factor -> . UnaryOp Primary
    (60) Primary -> . INTLIT
    (61) Primary -> . FLOATLIT
    (62) Primary -> . ID
    (63) Primary -> . ID ( )
    (64) Primary -> . ID ( Primary )
    (58) UnaryOp -> . -
    (59) UnaryOp -> . !

    INTLIT          shift and go to state 65
    FLOATLIT        shift and go to state 66
    ID              shift and go to state 55
    -               shift and go to state 67
    !               shift and go to state 68

    Relation                       shift and go to state 106
    Addition                       shift and go to state 60
    Term                           shift and go to state 61
    Factor                         shift and go to state 62
    Primary                        shift and go to state 63
    UnaryOp                        shift and go to state 64

state 82

    (39) EquOp -> EQ .

    INTLIT          reduce using rule 39 (EquOp -> EQ .)
    FLOATLIT        reduce using rule 39 (EquOp -> EQ .)
    ID              reduce using rule 39 (EquOp -> EQ .)
    -               reduce using rule 39 (EquOp -> EQ .)
    !               reduce using rule 39 (EquOp -> EQ .)


state 83

    (40) EquOp -> NEQ .

    INTLIT          reduce using rule 40 (EquOp -> NEQ .)
    FLOATLIT        reduce using rule 40 (EquOp -> NEQ .)
    ID              reduce using rule 40 (EquOp -> NEQ .)
    -               reduce using rule 40 (EquOp -> NEQ .)
    !               reduce using rule 40 (EquOp -> NEQ .)


state 84

    (42) Relation -> Addition RelOp . Addition
    (47) Addition -> . Term
    (48) Addition -> . Addition AddOp Term
    (51) Term -> . Factor
    (52) Term -> . Term MulOp Primary
    (56) Factor -> . Primary
    (57) Factor -> . UnaryOp Primary
    (60) Primary -> . INTLIT
    (61) Primary -> . FLOATLIT
    (62) Primary -> . ID
    (63) Primary -> . ID ( )
    (64) Primary -> . ID ( Primary )
    (58) UnaryOp -> . -
    (59) UnaryOp -> . !

    INTLIT          shift and go to state 65
    FLOATLIT        shift and go to state 66
    ID              shift and go to state 55
    -               shift and go to state 67
    !               shift and go to state 68

    Addition                       shift and go to state 107
    Term                           shift and go to state 61
    Factor                         shift and go to state 62
    Primary                        shift and go to state 63
    UnaryOp                        shift and go to state 64

state 85

    (48) Addition -> Addition AddOp . Term
    (51) Term -> . Factor
    (52) Term -> . Term MulOp Primary
    (56) Factor -> . Primary
    (57) Factor -> . UnaryOp Primary
    (60) Primary -> . INTLIT
    (61) Primary -> . FLOATLIT
    (62) Primary -> . ID
    (63) Primary -> . ID ( )
    (64) Primary -> . ID ( Primary )
    (58) UnaryOp -> . -
    (59) UnaryOp -> . !

    INTLIT          shift and go to state 65
    FLOATLIT        shift and go to state 66
    ID              shift and go to state 55
    -               shift and go to state 67
    !               shift and go to state 68

    Term                           shift and go to state 108
    Factor                         shift and go to state 62
    Primary                        shift and go to state 63
    UnaryOp                        shift and go to state 64

state 86

    (43) RelOp -> < .

    INTLIT          reduce using rule 43 (RelOp -> < .)
    FLOATLIT        reduce using rule 43 (RelOp -> < .)
    ID              reduce using rule 43 (RelOp -> < .)
    -               reduce using rule 43 (RelOp -> < .)
    !               reduce using rule 43 (RelOp -> < .)


state 87

    (44) RelOp -> LTE .

    INTLIT          reduce using rule 44 (RelOp -> LTE .)
    FLOATLIT        reduce using rule 44 (RelOp -> LTE .)
    ID              reduce using rule 44 (RelOp -> LTE .)
    -               reduce using rule 44 (RelOp -> LTE .)
    !               reduce using rule 44 (RelOp -> LTE .)


state 88

    (45) RelOp -> > .

    INTLIT          reduce using rule 45 (RelOp -> > .)
    FLOATLIT        reduce using rule 45 (RelOp -> > .)
    ID              reduce using rule 45 (RelOp -> > .)
    -               reduce using rule 45 (RelOp -> > .)
    !               reduce using rule 45 (RelOp -> > .)


state 89

    (46) RelOp -> GTE .

    INTLIT          reduce using rule 46 (RelOp -> GTE .)
    FLOATLIT        reduce using rule 46 (RelOp -> GTE .)
    ID              reduce using rule 46 (RelOp -> GTE .)
    -               reduce using rule 46 (RelOp -> GTE .)
    !               reduce using rule 46 (RelOp -> GTE .)


state 90

    (49) AddOp -> + .

    INTLIT          reduce using rule 49 (AddOp -> + .)
    FLOATLIT        reduce using rule 49 (AddOp -> + .)
    ID              reduce using rule 49 (AddOp -> + .)
    -               reduce using rule 49 (AddOp -> + .)
    !               reduce using rule 49 (AddOp -> + .)


state 91

    (50) AddOp -> - .

    INTLIT          reduce using rule 50 (AddOp -> - .)
    FLOATLIT        reduce using rule 50 (AddOp -> - .)
    ID              reduce using rule 50 (AddOp -> - .)
    -               reduce using rule 50 (AddOp -> - .)
    !               reduce using rule 50 (AddOp -> - .)


state 92

    (52) Term -> Term MulOp . Primary
    (60) Primary -> . INTLIT
    (61) Primary -> . FLOATLIT
    (62) Primary -> . ID
    (63) Primary -> . ID ( )
    (64) Primary -> . ID ( Primary )

    INTLIT          shift and go to state 65
    FLOATLIT        shift and go to state 66
    ID              shift and go to state 55

    Primary                        shift and go to state 109

state 93

    (53) MulOp -> * .

    INTLIT          reduce using rule 53 (MulOp -> * .)
    FLOATLIT        reduce using rule 53 (MulOp -> * .)
    ID              reduce using rule 53 (MulOp -> * .)


state 94

    (54) MulOp -> / .

    INTLIT          reduce using rule 54 (MulOp -> / .)
    FLOATLIT        reduce using rule 54 (MulOp -> / .)
    ID              reduce using rule 54 (MulOp -> / .)


state 95

    (55) MulOp -> % .

    INTLIT          reduce using rule 55 (MulOp -> % .)
    FLOATLIT        reduce using rule 55 (MulOp -> % .)
    ID              reduce using rule 55 (MulOp -> % .)


state 96

    (57) Factor -> UnaryOp Primary .

    *               reduce using rule 57 (Factor -> UnaryOp Primary .)
    /               reduce using rule 57 (Factor -> UnaryOp Primary .)
    %               reduce using rule 57 (Factor -> UnaryOp Primary .)
    <               reduce using rule 57 (Factor -> UnaryOp Primary .)
    LTE             reduce using rule 57 (Factor -> UnaryOp Primary .)
    >               reduce using rule 57 (Factor -> UnaryOp Primary .)
    GTE             reduce using rule 57 (Factor -> UnaryOp Primary .)
    +               reduce using rule 57 (Factor -> UnaryOp Primary .)
    -               reduce using rule 57 (Factor -> UnaryOp Primary .)
    EQ              reduce using rule 57 (Factor -> UnaryOp Primary .)
    NEQ             reduce using rule 57 (Factor -> UnaryOp Primary .)
    AND             reduce using rule 57 (Factor -> UnaryOp Primary .)
    ;               reduce using rule 57 (Factor -> UnaryOp Primary .)
    OR              reduce using rule 57 (Factor -> UnaryOp Primary .)
    )               reduce using rule 57 (Factor -> UnaryOp Primary .)


state 97

    (8) ReturnStatement -> RETURN Expression ; .

    }               reduce using rule 8 (ReturnStatement -> RETURN Expression ; .)


state 98

    (29) IfStatement -> IF ( Expression ) . Statement ELSE Statement
    (22) Statement -> . Assignment
    (23) Statement -> . IfStatement
    (24) Statement -> . WhileStatement
    (25) Statement -> . ForStatement
    (26) Statement -> . ;
    (27) Statement -> . Block
    (32) Assignment -> . ID = Expression ;
    (29) IfStatement -> . IF ( Expression ) Statement ELSE Statement
    (30) WhileStatement -> . WHILE ( Expression ) Statement
    (31) ForStatement -> . FOR ( Assignment Expression ; Assignment ) Statement
    (28) Block -> . { Statements }

    ;               shift and go to state 37
    ID              shift and go to state 28
    IF              shift and go to state 39
    WHILE           shift and go to state 40
    FOR             shift and go to state 41
    {               shift and go to state 29

    Statement                      shift and go to state 110
    Assignment                     shift and go to state 33
    IfStatement                    shift and go to state 34
    WhileStatement                 shift and go to state 35
    ForStatement                   shift and go to state 36
    Block                          shift and go to state 38

state 99

    (30) WhileStatement -> WHILE ( Expression ) . Statement
    (22) Statement -> . Assignment
    (23) Statement -> . IfStatement
    (24) Statement -> . WhileStatement
    (25) Statement -> . ForStatement
    (26) Statement -> . ;
    (27) Statement -> . Block
    (32) Assignment -> . ID = Expression ;
    (29) IfStatement -> . IF ( Expression ) Statement ELSE Statement
    (30) WhileStatement -> . WHILE ( Expression ) Statement
    (31) ForStatement -> . FOR ( Assignment Expression ; Assignment ) Statement
    (28) Block -> . { Statements }

    ;               shift and go to state 37
    ID              shift and go to state 28
    IF              shift and go to state 39
    WHILE           shift and go to state 40
    FOR             shift and go to state 41
    {               shift and go to state 29

    Statement                      shift and go to state 111
    Assignment                     shift and go to state 33
    IfStatement                    shift and go to state 34
    WhileStatement                 shift and go to state 35
    ForStatement                   shift and go to state 36
    Block                          shift and go to state 38

state 100

    (31) ForStatement -> FOR ( Assignment Expression . ; Assignment ) Statement
    (34) Expression -> Expression . OR Conjunction

    ;               shift and go to state 112
    OR              shift and go to state 79


state 101

    (4) Function -> FunctionReturnType ID ( Params ) { Declarations Statements ReturnStatement } .

    VOID            reduce using rule 4 (Function -> FunctionReturnType ID ( Params ) { Declarations Statements ReturnStatement } .)
    INT             reduce using rule 4 (Function -> FunctionReturnType ID ( Params ) { Declarations Statements ReturnStatement } .)
    BOOL            reduce using rule 4 (Function -> FunctionReturnType ID ( Params ) { Declarations Statements ReturnStatement } .)
    FLOAT           reduce using rule 4 (Function -> FunctionReturnType ID ( Params ) { Declarations Statements ReturnStatement } .)
    CHAR            reduce using rule 4 (Function -> FunctionReturnType ID ( Params ) { Declarations Statements ReturnStatement } .)
    $end            reduce using rule 4 (Function -> FunctionReturnType ID ( Params ) { Declarations Statements ReturnStatement } .)


state 102

    (63) Primary -> ID ( ) .

    *               reduce using rule 63 (Primary -> ID ( ) .)
    /               reduce using rule 63 (Primary -> ID ( ) .)
    %               reduce using rule 63 (Primary -> ID ( ) .)
    <               reduce using rule 63 (Primary -> ID ( ) .)
    LTE             reduce using rule 63 (Primary -> ID ( ) .)
    >               reduce using rule 63 (Primary -> ID ( ) .)
    GTE             reduce using rule 63 (Primary -> ID ( ) .)
    +               reduce using rule 63 (Primary -> ID ( ) .)
    -               reduce using rule 63 (Primary -> ID ( ) .)
    EQ              reduce using rule 63 (Primary -> ID ( ) .)
    NEQ             reduce using rule 63 (Primary -> ID ( ) .)
    AND             reduce using rule 63 (Primary -> ID ( ) .)
    ;               reduce using rule 63 (Primary -> ID ( ) .)
    OR              reduce using rule 63 (Primary -> ID ( ) .)
    )               reduce using rule 63 (Primary -> ID ( ) .)


state 103

    (64) Primary -> ID ( Primary . )

    )               shift and go to state 113


state 104

    (34) Expression -> Expression OR Conjunction .
    (36) Conjunction -> Conjunction . AND Equality

    ;               reduce using rule 34 (Expression -> Expression OR Conjunction .)
    OR              reduce using rule 34 (Expression -> Expression OR Conjunction .)
    )               reduce using rule 34 (Expression -> Expression OR Conjunction .)
    AND             shift and go to state 80


state 105

    (36) Conjunction -> Conjunction AND Equality .

    AND             reduce using rule 36 (Conjunction -> Conjunction AND Equality .)
    ;               reduce using rule 36 (Conjunction -> Conjunction AND Equality .)
    OR              reduce using rule 36 (Conjunction -> Conjunction AND Equality .)
    )               reduce using rule 36 (Conjunction -> Conjunction AND Equality .)


state 106

    (38) Equality -> Relation EquOp Relation .

    AND             reduce using rule 38 (Equality -> Relation EquOp Relation .)
    ;               reduce using rule 38 (Equality -> Relation EquOp Relation .)
    OR              reduce using rule 38 (Equality -> Relation EquOp Relation .)
    )               reduce using rule 38 (Equality -> Relation EquOp Relation .)


state 107

    (42) Relation -> Addition RelOp Addition .
    (48) Addition -> Addition . AddOp Term
    (49) AddOp -> . +
    (50) AddOp -> . -

    EQ              reduce using rule 42 (Relation -> Addition RelOp Addition .)
    NEQ             reduce using rule 42 (Relation -> Addition RelOp Addition .)
    AND             reduce using rule 42 (Relation -> Addition RelOp Addition .)
    ;               reduce using rule 42 (Relation -> Addition RelOp Addition .)
    OR              reduce using rule 42 (Relation -> Addition RelOp Addition .)
    )               reduce using rule 42 (Relation -> Addition RelOp Addition .)
    +               shift and go to state 90
    -               shift and go to state 91

    AddOp                          shift and go to state 85

state 108

    (48) Addition -> Addition AddOp Term .
    (52) Term -> Term . MulOp Primary
    (53) MulOp -> . *
    (54) MulOp -> . /
    (55) MulOp -> . %

    <               reduce using rule 48 (Addition -> Addition AddOp Term .)
    LTE             reduce using rule 48 (Addition -> Addition AddOp Term .)
    >               reduce using rule 48 (Addition -> Addition AddOp Term .)
    GTE             reduce using rule 48 (Addition -> Addition AddOp Term .)
    +               reduce using rule 48 (Addition -> Addition AddOp Term .)
    -               reduce using rule 48 (Addition -> Addition AddOp Term .)
    EQ              reduce using rule 48 (Addition -> Addition AddOp Term .)
    NEQ             reduce using rule 48 (Addition -> Addition AddOp Term .)
    AND             reduce using rule 48 (Addition -> Addition AddOp Term .)
    ;               reduce using rule 48 (Addition -> Addition AddOp Term .)
    OR              reduce using rule 48 (Addition -> Addition AddOp Term .)
    )               reduce using rule 48 (Addition -> Addition AddOp Term .)
    *               shift and go to state 93
    /               shift and go to state 94
    %               shift and go to state 95

    MulOp                          shift and go to state 92

state 109

    (52) Term -> Term MulOp Primary .

    *               reduce using rule 52 (Term -> Term MulOp Primary .)
    /               reduce using rule 52 (Term -> Term MulOp Primary .)
    %               reduce using rule 52 (Term -> Term MulOp Primary .)
    <               reduce using rule 52 (Term -> Term MulOp Primary .)
    LTE             reduce using rule 52 (Term -> Term MulOp Primary .)
    >               reduce using rule 52 (Term -> Term MulOp Primary .)
    GTE             reduce using rule 52 (Term -> Term MulOp Primary .)
    +               reduce using rule 52 (Term -> Term MulOp Primary .)
    -               reduce using rule 52 (Term -> Term MulOp Primary .)
    EQ              reduce using rule 52 (Term -> Term MulOp Primary .)
    NEQ             reduce using rule 52 (Term -> Term MulOp Primary .)
    AND             reduce using rule 52 (Term -> Term MulOp Primary .)
    ;               reduce using rule 52 (Term -> Term MulOp Primary .)
    OR              reduce using rule 52 (Term -> Term MulOp Primary .)
    )               reduce using rule 52 (Term -> Term MulOp Primary .)


state 110

    (29) IfStatement -> IF ( Expression ) Statement . ELSE Statement

    ELSE            shift and go to state 114


state 111

    (30) WhileStatement -> WHILE ( Expression ) Statement .

    ;               reduce using rule 30 (WhileStatement -> WHILE ( Expression ) Statement .)
    ID              reduce using rule 30 (WhileStatement -> WHILE ( Expression ) Statement .)
    IF              reduce using rule 30 (WhileStatement -> WHILE ( Expression ) Statement .)
    WHILE           reduce using rule 30 (WhileStatement -> WHILE ( Expression ) Statement .)
    FOR             reduce using rule 30 (WhileStatement -> WHILE ( Expression ) Statement .)
    {               reduce using rule 30 (WhileStatement -> WHILE ( Expression ) Statement .)
    RETURN          reduce using rule 30 (WhileStatement -> WHILE ( Expression ) Statement .)
    }               reduce using rule 30 (WhileStatement -> WHILE ( Expression ) Statement .)
    ELSE            reduce using rule 30 (WhileStatement -> WHILE ( Expression ) Statement .)


state 112

    (31) ForStatement -> FOR ( Assignment Expression ; . Assignment ) Statement
    (32) Assignment -> . ID = Expression ;

    ID              shift and go to state 28

    Assignment                     shift and go to state 115

state 113

    (64) Primary -> ID ( Primary ) .

    *               reduce using rule 64 (Primary -> ID ( Primary ) .)
    /               reduce using rule 64 (Primary -> ID ( Primary ) .)
    %               reduce using rule 64 (Primary -> ID ( Primary ) .)
    <               reduce using rule 64 (Primary -> ID ( Primary ) .)
    LTE             reduce using rule 64 (Primary -> ID ( Primary ) .)
    >               reduce using rule 64 (Primary -> ID ( Primary ) .)
    GTE             reduce using rule 64 (Primary -> ID ( Primary ) .)
    +               reduce using rule 64 (Primary -> ID ( Primary ) .)
    -               reduce using rule 64 (Primary -> ID ( Primary ) .)
    EQ              reduce using rule 64 (Primary -> ID ( Primary ) .)
    NEQ             reduce using rule 64 (Primary -> ID ( Primary ) .)
    AND             reduce using rule 64 (Primary -> ID ( Primary ) .)
    ;               reduce using rule 64 (Primary -> ID ( Primary ) .)
    OR              reduce using rule 64 (Primary -> ID ( Primary ) .)
    )               reduce using rule 64 (Primary -> ID ( Primary ) .)


state 114

    (29) IfStatement -> IF ( Expression ) Statement ELSE . Statement
    (22) Statement -> . Assignment
    (23) Statement -> . IfStatement
    (24) Statement -> . WhileStatement
    (25) Statement -> . ForStatement
    (26) Statement -> . ;
    (27) Statement -> . Block
    (32) Assignment -> . ID = Expression ;
    (29) IfStatement -> . IF ( Expression ) Statement ELSE Statement
    (30) WhileStatement -> . WHILE ( Expression ) Statement
    (31) ForStatement -> . FOR ( Assignment Expression ; Assignment ) Statement
    (28) Block -> . { Statements }

    ;               shift and go to state 37
    ID              shift and go to state 28
    IF              shift and go to state 39
    WHILE           shift and go to state 40
    FOR             shift and go to state 41
    {               shift and go to state 29

    Statement                      shift and go to state 116
    Assignment                     shift and go to state 33
    IfStatement                    shift and go to state 34
    WhileStatement                 shift and go to state 35
    ForStatement                   shift and go to state 36
    Block                          shift and go to state 38

state 115

    (31) ForStatement -> FOR ( Assignment Expression ; Assignment . ) Statement

    )               shift and go to state 117


state 116

    (29) IfStatement -> IF ( Expression ) Statement ELSE Statement .

    ;               reduce using rule 29 (IfStatement -> IF ( Expression ) Statement ELSE Statement .)
    ID              reduce using rule 29 (IfStatement -> IF ( Expression ) Statement ELSE Statement .)
    IF              reduce using rule 29 (IfStatement -> IF ( Expression ) Statement ELSE Statement .)
    WHILE           reduce using rule 29 (IfStatement -> IF ( Expression ) Statement ELSE Statement .)
    FOR             reduce using rule 29 (IfStatement -> IF ( Expression ) Statement ELSE Statement .)
    {               reduce using rule 29 (IfStatement -> IF ( Expression ) Statement ELSE Statement .)
    RETURN          reduce using rule 29 (IfStatement -> IF ( Expression ) Statement ELSE Statement .)
    }               reduce using rule 29 (IfStatement -> IF ( Expression ) Statement ELSE Statement .)
    ELSE            reduce using rule 29 (IfStatement -> IF ( Expression ) Statement ELSE Statement .)


state 117

    (31) ForStatement -> FOR ( Assignment Expression ; Assignment ) . Statement
    (22) Statement -> . Assignment
    (23) Statement -> . IfStatement
    (24) Statement -> . WhileStatement
    (25) Statement -> . ForStatement
    (26) Statement -> . ;
    (27) Statement -> . Block
    (32) Assignment -> . ID = Expression ;
    (29) IfStatement -> . IF ( Expression ) Statement ELSE Statement
    (30) WhileStatement -> . WHILE ( Expression ) Statement
    (31) ForStatement -> . FOR ( Assignment Expression ; Assignment ) Statement
    (28) Block -> . { Statements }

    ;               shift and go to state 37
    ID              shift and go to state 28
    IF              shift and go to state 39
    WHILE           shift and go to state 40
    FOR             shift and go to state 41
    {               shift and go to state 29

    Assignment                     shift and go to state 33
    Statement                      shift and go to state 118
    IfStatement                    shift and go to state 34
    WhileStatement                 shift and go to state 35
    ForStatement                   shift and go to state 36
    Block                          shift and go to state 38

state 118

    (31) ForStatement -> FOR ( Assignment Expression ; Assignment ) Statement .

    ;               reduce using rule 31 (ForStatement -> FOR ( Assignment Expression ; Assignment ) Statement .)
    ID              reduce using rule 31 (ForStatement -> FOR ( Assignment Expression ; Assignment ) Statement .)
    IF              reduce using rule 31 (ForStatement -> FOR ( Assignment Expression ; Assignment ) Statement .)
    WHILE           reduce using rule 31 (ForStatement -> FOR ( Assignment Expression ; Assignment ) Statement .)
    FOR             reduce using rule 31 (ForStatement -> FOR ( Assignment Expression ; Assignment ) Statement .)
    {               reduce using rule 31 (ForStatement -> FOR ( Assignment Expression ; Assignment ) Statement .)
    RETURN          reduce using rule 31 (ForStatement -> FOR ( Assignment Expression ; Assignment ) Statement .)
    }               reduce using rule 31 (ForStatement -> FOR ( Assignment Expression ; Assignment ) Statement .)
    ELSE            reduce using rule 31 (ForStatement -> FOR ( Assignment Expression ; Assignment ) Statement .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for ) in state 13 resolved as shift
