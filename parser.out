Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> Program
Rule 1     Program -> Function
Rule 2     Function -> Type ID ( ) { Declarations Statements ReturnStatement }
Rule 3     ReturnStatement -> RETURN Expression ;
Rule 4     empty -> <empty>
Rule 5     Declarations -> Declaration Declarations
Rule 6     Declarations -> empty
Rule 7     Declaration -> Type ID ;
Rule 8     Type -> INT
Rule 9     Type -> BOOL
Rule 10    Type -> FLOAT
Rule 11    Type -> CHAR
Rule 12    Statements -> Statement Statements
Rule 13    Statements -> empty
Rule 14    Statement -> Assignment
Rule 15    Statement -> IfStatement
Rule 16    Statement -> WhileStatement
Rule 17    Statement -> ForStatement
Rule 18    Statement -> ;
Rule 19    Statement -> Block
Rule 20    Block -> { Statements }
Rule 21    IfStatement -> IF ( Expression ) Statement ELSE Statement
Rule 22    WhileStatement -> WHILE ( Expression ) Statement
Rule 23    ForStatement -> FOR ( Assignment Expression ; Assignment ) Statement
Rule 24    Assignment -> ID = Expression ;
Rule 25    Expression -> Conjunction
Rule 26    Expression -> Expression OR Conjunction
Rule 27    Conjunction -> Equality
Rule 28    Conjunction -> Conjunction AND Equality
Rule 29    Equality -> Relation
Rule 30    Equality -> Relation EquOp Relation
Rule 31    EquOp -> EQ
Rule 32    EquOp -> NEQ
Rule 33    Relation -> Addition
Rule 34    Relation -> Addition RelOp Addition
Rule 35    RelOp -> <
Rule 36    RelOp -> LTE
Rule 37    RelOp -> >
Rule 38    RelOp -> GTE
Rule 39    Addition -> Term
Rule 40    Addition -> Addition AddOp Term
Rule 41    AddOp -> +
Rule 42    AddOp -> -
Rule 43    Term -> Factor
Rule 44    Term -> Term MulOp Primary
Rule 45    MulOp -> *
Rule 46    MulOp -> /
Rule 47    MulOp -> %
Rule 48    Factor -> Primary
Rule 49    Factor -> UnaryOp Primary
Rule 50    UnaryOp -> -
Rule 51    UnaryOp -> !
Rule 52    Primary -> INTLIT
Rule 53    Primary -> ID

Terminals, with rules where they appear

!                    : 51
%                    : 47
(                    : 2 21 22 23
)                    : 2 21 22 23
*                    : 45
+                    : 41
-                    : 42 50
/                    : 46
;                    : 3 7 18 23 24
<                    : 35
=                    : 24
>                    : 37
AND                  : 28
BOOL                 : 9
CHAR                 : 11
ELSE                 : 21
EQ                   : 31
FLOAT                : 10
FOR                  : 23
GTE                  : 38
ID                   : 2 7 24 53
IF                   : 21
INT                  : 8
INTLIT               : 52
LTE                  : 36
NEQ                  : 32
OR                   : 26
RETURN               : 3
WHILE                : 22
error                : 
{                    : 2 20
}                    : 2 20

Nonterminals, with rules where they appear

AddOp                : 40
Addition             : 33 34 34 40
Assignment           : 14 23 23
Block                : 19
Conjunction          : 25 26 28
Declaration          : 5
Declarations         : 2 5
EquOp                : 30
Equality             : 27 28
Expression           : 3 21 22 23 24 26
Factor               : 43
ForStatement         : 17
Function             : 1
IfStatement          : 15
MulOp                : 44
Primary              : 44 48 49
Program              : 0
RelOp                : 34
Relation             : 29 30 30
ReturnStatement      : 2
Statement            : 12 21 21 22 23
Statements           : 2 12 20
Term                 : 39 40 44
Type                 : 2 7
UnaryOp              : 49
WhileStatement       : 16
empty                : 6 13

Parsing method: LALR

state 0

    (0) S' -> . Program
    (1) Program -> . Function
    (2) Function -> . Type ID ( ) { Declarations Statements ReturnStatement }
    (8) Type -> . INT
    (9) Type -> . BOOL
    (10) Type -> . FLOAT
    (11) Type -> . CHAR

    INT             shift and go to state 4
    BOOL            shift and go to state 5
    FLOAT           shift and go to state 6
    CHAR            shift and go to state 7

    Program                        shift and go to state 1
    Function                       shift and go to state 2
    Type                           shift and go to state 3

state 1

    (0) S' -> Program .



state 2

    (1) Program -> Function .

    $end            reduce using rule 1 (Program -> Function .)


state 3

    (2) Function -> Type . ID ( ) { Declarations Statements ReturnStatement }

    ID              shift and go to state 8


state 4

    (8) Type -> INT .

    ID              reduce using rule 8 (Type -> INT .)


state 5

    (9) Type -> BOOL .

    ID              reduce using rule 9 (Type -> BOOL .)


state 6

    (10) Type -> FLOAT .

    ID              reduce using rule 10 (Type -> FLOAT .)


state 7

    (11) Type -> CHAR .

    ID              reduce using rule 11 (Type -> CHAR .)


state 8

    (2) Function -> Type ID . ( ) { Declarations Statements ReturnStatement }

    (               shift and go to state 9


state 9

    (2) Function -> Type ID ( . ) { Declarations Statements ReturnStatement }

    )               shift and go to state 10


state 10

    (2) Function -> Type ID ( ) . { Declarations Statements ReturnStatement }

    {               shift and go to state 11


state 11

    (2) Function -> Type ID ( ) { . Declarations Statements ReturnStatement }
    (5) Declarations -> . Declaration Declarations
    (6) Declarations -> . empty
    (7) Declaration -> . Type ID ;
    (4) empty -> .
    (8) Type -> . INT
    (9) Type -> . BOOL
    (10) Type -> . FLOAT
    (11) Type -> . CHAR

    ;               reduce using rule 4 (empty -> .)
    ID              reduce using rule 4 (empty -> .)
    IF              reduce using rule 4 (empty -> .)
    WHILE           reduce using rule 4 (empty -> .)
    FOR             reduce using rule 4 (empty -> .)
    {               reduce using rule 4 (empty -> .)
    RETURN          reduce using rule 4 (empty -> .)
    INT             shift and go to state 4
    BOOL            shift and go to state 5
    FLOAT           shift and go to state 6
    CHAR            shift and go to state 7

    Type                           shift and go to state 12
    Declarations                   shift and go to state 13
    Declaration                    shift and go to state 14
    empty                          shift and go to state 15

state 12

    (7) Declaration -> Type . ID ;

    ID              shift and go to state 16


state 13

    (2) Function -> Type ID ( ) { Declarations . Statements ReturnStatement }
    (12) Statements -> . Statement Statements
    (13) Statements -> . empty
    (14) Statement -> . Assignment
    (15) Statement -> . IfStatement
    (16) Statement -> . WhileStatement
    (17) Statement -> . ForStatement
    (18) Statement -> . ;
    (19) Statement -> . Block
    (4) empty -> .
    (24) Assignment -> . ID = Expression ;
    (21) IfStatement -> . IF ( Expression ) Statement ELSE Statement
    (22) WhileStatement -> . WHILE ( Expression ) Statement
    (23) ForStatement -> . FOR ( Assignment Expression ; Assignment ) Statement
    (20) Block -> . { Statements }

    ;               shift and go to state 26
    RETURN          reduce using rule 4 (empty -> .)
    ID              shift and go to state 17
    IF              shift and go to state 28
    WHILE           shift and go to state 29
    FOR             shift and go to state 30
    {               shift and go to state 18

    Statements                     shift and go to state 19
    Statement                      shift and go to state 20
    empty                          shift and go to state 21
    Assignment                     shift and go to state 22
    IfStatement                    shift and go to state 23
    WhileStatement                 shift and go to state 24
    ForStatement                   shift and go to state 25
    Block                          shift and go to state 27

state 14

    (5) Declarations -> Declaration . Declarations
    (5) Declarations -> . Declaration Declarations
    (6) Declarations -> . empty
    (7) Declaration -> . Type ID ;
    (4) empty -> .
    (8) Type -> . INT
    (9) Type -> . BOOL
    (10) Type -> . FLOAT
    (11) Type -> . CHAR

    ;               reduce using rule 4 (empty -> .)
    ID              reduce using rule 4 (empty -> .)
    IF              reduce using rule 4 (empty -> .)
    WHILE           reduce using rule 4 (empty -> .)
    FOR             reduce using rule 4 (empty -> .)
    {               reduce using rule 4 (empty -> .)
    RETURN          reduce using rule 4 (empty -> .)
    INT             shift and go to state 4
    BOOL            shift and go to state 5
    FLOAT           shift and go to state 6
    CHAR            shift and go to state 7

    Declaration                    shift and go to state 14
    Declarations                   shift and go to state 31
    empty                          shift and go to state 15
    Type                           shift and go to state 12

state 15

    (6) Declarations -> empty .

    ;               reduce using rule 6 (Declarations -> empty .)
    ID              reduce using rule 6 (Declarations -> empty .)
    IF              reduce using rule 6 (Declarations -> empty .)
    WHILE           reduce using rule 6 (Declarations -> empty .)
    FOR             reduce using rule 6 (Declarations -> empty .)
    {               reduce using rule 6 (Declarations -> empty .)
    RETURN          reduce using rule 6 (Declarations -> empty .)


state 16

    (7) Declaration -> Type ID . ;

    ;               shift and go to state 32


state 17

    (24) Assignment -> ID . = Expression ;

    =               shift and go to state 33


state 18

    (20) Block -> { . Statements }
    (12) Statements -> . Statement Statements
    (13) Statements -> . empty
    (14) Statement -> . Assignment
    (15) Statement -> . IfStatement
    (16) Statement -> . WhileStatement
    (17) Statement -> . ForStatement
    (18) Statement -> . ;
    (19) Statement -> . Block
    (4) empty -> .
    (24) Assignment -> . ID = Expression ;
    (21) IfStatement -> . IF ( Expression ) Statement ELSE Statement
    (22) WhileStatement -> . WHILE ( Expression ) Statement
    (23) ForStatement -> . FOR ( Assignment Expression ; Assignment ) Statement
    (20) Block -> . { Statements }

    ;               shift and go to state 26
    }               reduce using rule 4 (empty -> .)
    ID              shift and go to state 17
    IF              shift and go to state 28
    WHILE           shift and go to state 29
    FOR             shift and go to state 30
    {               shift and go to state 18

    Statements                     shift and go to state 34
    Statement                      shift and go to state 20
    empty                          shift and go to state 21
    Assignment                     shift and go to state 22
    IfStatement                    shift and go to state 23
    WhileStatement                 shift and go to state 24
    ForStatement                   shift and go to state 25
    Block                          shift and go to state 27

state 19

    (2) Function -> Type ID ( ) { Declarations Statements . ReturnStatement }
    (3) ReturnStatement -> . RETURN Expression ;

    RETURN          shift and go to state 36

    ReturnStatement                shift and go to state 35

state 20

    (12) Statements -> Statement . Statements
    (12) Statements -> . Statement Statements
    (13) Statements -> . empty
    (14) Statement -> . Assignment
    (15) Statement -> . IfStatement
    (16) Statement -> . WhileStatement
    (17) Statement -> . ForStatement
    (18) Statement -> . ;
    (19) Statement -> . Block
    (4) empty -> .
    (24) Assignment -> . ID = Expression ;
    (21) IfStatement -> . IF ( Expression ) Statement ELSE Statement
    (22) WhileStatement -> . WHILE ( Expression ) Statement
    (23) ForStatement -> . FOR ( Assignment Expression ; Assignment ) Statement
    (20) Block -> . { Statements }

    ;               shift and go to state 26
    RETURN          reduce using rule 4 (empty -> .)
    }               reduce using rule 4 (empty -> .)
    ID              shift and go to state 17
    IF              shift and go to state 28
    WHILE           shift and go to state 29
    FOR             shift and go to state 30
    {               shift and go to state 18

    Statement                      shift and go to state 20
    Statements                     shift and go to state 37
    empty                          shift and go to state 21
    Assignment                     shift and go to state 22
    IfStatement                    shift and go to state 23
    WhileStatement                 shift and go to state 24
    ForStatement                   shift and go to state 25
    Block                          shift and go to state 27

state 21

    (13) Statements -> empty .

    RETURN          reduce using rule 13 (Statements -> empty .)
    }               reduce using rule 13 (Statements -> empty .)


state 22

    (14) Statement -> Assignment .

    ;               reduce using rule 14 (Statement -> Assignment .)
    ID              reduce using rule 14 (Statement -> Assignment .)
    IF              reduce using rule 14 (Statement -> Assignment .)
    WHILE           reduce using rule 14 (Statement -> Assignment .)
    FOR             reduce using rule 14 (Statement -> Assignment .)
    {               reduce using rule 14 (Statement -> Assignment .)
    RETURN          reduce using rule 14 (Statement -> Assignment .)
    }               reduce using rule 14 (Statement -> Assignment .)
    ELSE            reduce using rule 14 (Statement -> Assignment .)


state 23

    (15) Statement -> IfStatement .

    ;               reduce using rule 15 (Statement -> IfStatement .)
    ID              reduce using rule 15 (Statement -> IfStatement .)
    IF              reduce using rule 15 (Statement -> IfStatement .)
    WHILE           reduce using rule 15 (Statement -> IfStatement .)
    FOR             reduce using rule 15 (Statement -> IfStatement .)
    {               reduce using rule 15 (Statement -> IfStatement .)
    RETURN          reduce using rule 15 (Statement -> IfStatement .)
    }               reduce using rule 15 (Statement -> IfStatement .)
    ELSE            reduce using rule 15 (Statement -> IfStatement .)


state 24

    (16) Statement -> WhileStatement .

    ;               reduce using rule 16 (Statement -> WhileStatement .)
    ID              reduce using rule 16 (Statement -> WhileStatement .)
    IF              reduce using rule 16 (Statement -> WhileStatement .)
    WHILE           reduce using rule 16 (Statement -> WhileStatement .)
    FOR             reduce using rule 16 (Statement -> WhileStatement .)
    {               reduce using rule 16 (Statement -> WhileStatement .)
    RETURN          reduce using rule 16 (Statement -> WhileStatement .)
    }               reduce using rule 16 (Statement -> WhileStatement .)
    ELSE            reduce using rule 16 (Statement -> WhileStatement .)


state 25

    (17) Statement -> ForStatement .

    ;               reduce using rule 17 (Statement -> ForStatement .)
    ID              reduce using rule 17 (Statement -> ForStatement .)
    IF              reduce using rule 17 (Statement -> ForStatement .)
    WHILE           reduce using rule 17 (Statement -> ForStatement .)
    FOR             reduce using rule 17 (Statement -> ForStatement .)
    {               reduce using rule 17 (Statement -> ForStatement .)
    RETURN          reduce using rule 17 (Statement -> ForStatement .)
    }               reduce using rule 17 (Statement -> ForStatement .)
    ELSE            reduce using rule 17 (Statement -> ForStatement .)


state 26

    (18) Statement -> ; .

    ;               reduce using rule 18 (Statement -> ; .)
    ID              reduce using rule 18 (Statement -> ; .)
    IF              reduce using rule 18 (Statement -> ; .)
    WHILE           reduce using rule 18 (Statement -> ; .)
    FOR             reduce using rule 18 (Statement -> ; .)
    {               reduce using rule 18 (Statement -> ; .)
    RETURN          reduce using rule 18 (Statement -> ; .)
    }               reduce using rule 18 (Statement -> ; .)
    ELSE            reduce using rule 18 (Statement -> ; .)


state 27

    (19) Statement -> Block .

    ;               reduce using rule 19 (Statement -> Block .)
    ID              reduce using rule 19 (Statement -> Block .)
    IF              reduce using rule 19 (Statement -> Block .)
    WHILE           reduce using rule 19 (Statement -> Block .)
    FOR             reduce using rule 19 (Statement -> Block .)
    {               reduce using rule 19 (Statement -> Block .)
    RETURN          reduce using rule 19 (Statement -> Block .)
    }               reduce using rule 19 (Statement -> Block .)
    ELSE            reduce using rule 19 (Statement -> Block .)


state 28

    (21) IfStatement -> IF . ( Expression ) Statement ELSE Statement

    (               shift and go to state 38


state 29

    (22) WhileStatement -> WHILE . ( Expression ) Statement

    (               shift and go to state 39


state 30

    (23) ForStatement -> FOR . ( Assignment Expression ; Assignment ) Statement

    (               shift and go to state 40


state 31

    (5) Declarations -> Declaration Declarations .

    ;               reduce using rule 5 (Declarations -> Declaration Declarations .)
    ID              reduce using rule 5 (Declarations -> Declaration Declarations .)
    IF              reduce using rule 5 (Declarations -> Declaration Declarations .)
    WHILE           reduce using rule 5 (Declarations -> Declaration Declarations .)
    FOR             reduce using rule 5 (Declarations -> Declaration Declarations .)
    {               reduce using rule 5 (Declarations -> Declaration Declarations .)
    RETURN          reduce using rule 5 (Declarations -> Declaration Declarations .)


state 32

    (7) Declaration -> Type ID ; .

    INT             reduce using rule 7 (Declaration -> Type ID ; .)
    BOOL            reduce using rule 7 (Declaration -> Type ID ; .)
    FLOAT           reduce using rule 7 (Declaration -> Type ID ; .)
    CHAR            reduce using rule 7 (Declaration -> Type ID ; .)
    ;               reduce using rule 7 (Declaration -> Type ID ; .)
    ID              reduce using rule 7 (Declaration -> Type ID ; .)
    IF              reduce using rule 7 (Declaration -> Type ID ; .)
    WHILE           reduce using rule 7 (Declaration -> Type ID ; .)
    FOR             reduce using rule 7 (Declaration -> Type ID ; .)
    {               reduce using rule 7 (Declaration -> Type ID ; .)
    RETURN          reduce using rule 7 (Declaration -> Type ID ; .)


state 33

    (24) Assignment -> ID = . Expression ;
    (25) Expression -> . Conjunction
    (26) Expression -> . Expression OR Conjunction
    (27) Conjunction -> . Equality
    (28) Conjunction -> . Conjunction AND Equality
    (29) Equality -> . Relation
    (30) Equality -> . Relation EquOp Relation
    (33) Relation -> . Addition
    (34) Relation -> . Addition RelOp Addition
    (39) Addition -> . Term
    (40) Addition -> . Addition AddOp Term
    (43) Term -> . Factor
    (44) Term -> . Term MulOp Primary
    (48) Factor -> . Primary
    (49) Factor -> . UnaryOp Primary
    (52) Primary -> . INTLIT
    (53) Primary -> . ID
    (50) UnaryOp -> . -
    (51) UnaryOp -> . !

    INTLIT          shift and go to state 51
    ID              shift and go to state 41
    -               shift and go to state 52
    !               shift and go to state 53

    Expression                     shift and go to state 42
    Conjunction                    shift and go to state 43
    Equality                       shift and go to state 44
    Relation                       shift and go to state 45
    Addition                       shift and go to state 46
    Term                           shift and go to state 47
    Factor                         shift and go to state 48
    Primary                        shift and go to state 49
    UnaryOp                        shift and go to state 50

state 34

    (20) Block -> { Statements . }

    }               shift and go to state 54


state 35

    (2) Function -> Type ID ( ) { Declarations Statements ReturnStatement . }

    }               shift and go to state 55


state 36

    (3) ReturnStatement -> RETURN . Expression ;
    (25) Expression -> . Conjunction
    (26) Expression -> . Expression OR Conjunction
    (27) Conjunction -> . Equality
    (28) Conjunction -> . Conjunction AND Equality
    (29) Equality -> . Relation
    (30) Equality -> . Relation EquOp Relation
    (33) Relation -> . Addition
    (34) Relation -> . Addition RelOp Addition
    (39) Addition -> . Term
    (40) Addition -> . Addition AddOp Term
    (43) Term -> . Factor
    (44) Term -> . Term MulOp Primary
    (48) Factor -> . Primary
    (49) Factor -> . UnaryOp Primary
    (52) Primary -> . INTLIT
    (53) Primary -> . ID
    (50) UnaryOp -> . -
    (51) UnaryOp -> . !

    INTLIT          shift and go to state 51
    ID              shift and go to state 41
    -               shift and go to state 52
    !               shift and go to state 53

    Expression                     shift and go to state 56
    Conjunction                    shift and go to state 43
    Equality                       shift and go to state 44
    Relation                       shift and go to state 45
    Addition                       shift and go to state 46
    Term                           shift and go to state 47
    Factor                         shift and go to state 48
    Primary                        shift and go to state 49
    UnaryOp                        shift and go to state 50

state 37

    (12) Statements -> Statement Statements .

    RETURN          reduce using rule 12 (Statements -> Statement Statements .)
    }               reduce using rule 12 (Statements -> Statement Statements .)


state 38

    (21) IfStatement -> IF ( . Expression ) Statement ELSE Statement
    (25) Expression -> . Conjunction
    (26) Expression -> . Expression OR Conjunction
    (27) Conjunction -> . Equality
    (28) Conjunction -> . Conjunction AND Equality
    (29) Equality -> . Relation
    (30) Equality -> . Relation EquOp Relation
    (33) Relation -> . Addition
    (34) Relation -> . Addition RelOp Addition
    (39) Addition -> . Term
    (40) Addition -> . Addition AddOp Term
    (43) Term -> . Factor
    (44) Term -> . Term MulOp Primary
    (48) Factor -> . Primary
    (49) Factor -> . UnaryOp Primary
    (52) Primary -> . INTLIT
    (53) Primary -> . ID
    (50) UnaryOp -> . -
    (51) UnaryOp -> . !

    INTLIT          shift and go to state 51
    ID              shift and go to state 41
    -               shift and go to state 52
    !               shift and go to state 53

    Expression                     shift and go to state 57
    Conjunction                    shift and go to state 43
    Equality                       shift and go to state 44
    Relation                       shift and go to state 45
    Addition                       shift and go to state 46
    Term                           shift and go to state 47
    Factor                         shift and go to state 48
    Primary                        shift and go to state 49
    UnaryOp                        shift and go to state 50

state 39

    (22) WhileStatement -> WHILE ( . Expression ) Statement
    (25) Expression -> . Conjunction
    (26) Expression -> . Expression OR Conjunction
    (27) Conjunction -> . Equality
    (28) Conjunction -> . Conjunction AND Equality
    (29) Equality -> . Relation
    (30) Equality -> . Relation EquOp Relation
    (33) Relation -> . Addition
    (34) Relation -> . Addition RelOp Addition
    (39) Addition -> . Term
    (40) Addition -> . Addition AddOp Term
    (43) Term -> . Factor
    (44) Term -> . Term MulOp Primary
    (48) Factor -> . Primary
    (49) Factor -> . UnaryOp Primary
    (52) Primary -> . INTLIT
    (53) Primary -> . ID
    (50) UnaryOp -> . -
    (51) UnaryOp -> . !

    INTLIT          shift and go to state 51
    ID              shift and go to state 41
    -               shift and go to state 52
    !               shift and go to state 53

    Expression                     shift and go to state 58
    Conjunction                    shift and go to state 43
    Equality                       shift and go to state 44
    Relation                       shift and go to state 45
    Addition                       shift and go to state 46
    Term                           shift and go to state 47
    Factor                         shift and go to state 48
    Primary                        shift and go to state 49
    UnaryOp                        shift and go to state 50

state 40

    (23) ForStatement -> FOR ( . Assignment Expression ; Assignment ) Statement
    (24) Assignment -> . ID = Expression ;

    ID              shift and go to state 17

    Assignment                     shift and go to state 59

state 41

    (53) Primary -> ID .

    *               reduce using rule 53 (Primary -> ID .)
    /               reduce using rule 53 (Primary -> ID .)
    %               reduce using rule 53 (Primary -> ID .)
    <               reduce using rule 53 (Primary -> ID .)
    LTE             reduce using rule 53 (Primary -> ID .)
    >               reduce using rule 53 (Primary -> ID .)
    GTE             reduce using rule 53 (Primary -> ID .)
    +               reduce using rule 53 (Primary -> ID .)
    -               reduce using rule 53 (Primary -> ID .)
    EQ              reduce using rule 53 (Primary -> ID .)
    NEQ             reduce using rule 53 (Primary -> ID .)
    AND             reduce using rule 53 (Primary -> ID .)
    ;               reduce using rule 53 (Primary -> ID .)
    OR              reduce using rule 53 (Primary -> ID .)
    )               reduce using rule 53 (Primary -> ID .)


state 42

    (24) Assignment -> ID = Expression . ;
    (26) Expression -> Expression . OR Conjunction

    ;               shift and go to state 60
    OR              shift and go to state 61


state 43

    (25) Expression -> Conjunction .
    (28) Conjunction -> Conjunction . AND Equality

    ;               reduce using rule 25 (Expression -> Conjunction .)
    OR              reduce using rule 25 (Expression -> Conjunction .)
    )               reduce using rule 25 (Expression -> Conjunction .)
    AND             shift and go to state 62


state 44

    (27) Conjunction -> Equality .

    AND             reduce using rule 27 (Conjunction -> Equality .)
    ;               reduce using rule 27 (Conjunction -> Equality .)
    OR              reduce using rule 27 (Conjunction -> Equality .)
    )               reduce using rule 27 (Conjunction -> Equality .)


state 45

    (29) Equality -> Relation .
    (30) Equality -> Relation . EquOp Relation
    (31) EquOp -> . EQ
    (32) EquOp -> . NEQ

    AND             reduce using rule 29 (Equality -> Relation .)
    ;               reduce using rule 29 (Equality -> Relation .)
    OR              reduce using rule 29 (Equality -> Relation .)
    )               reduce using rule 29 (Equality -> Relation .)
    EQ              shift and go to state 64
    NEQ             shift and go to state 65

    EquOp                          shift and go to state 63

state 46

    (33) Relation -> Addition .
    (34) Relation -> Addition . RelOp Addition
    (40) Addition -> Addition . AddOp Term
    (35) RelOp -> . <
    (36) RelOp -> . LTE
    (37) RelOp -> . >
    (38) RelOp -> . GTE
    (41) AddOp -> . +
    (42) AddOp -> . -

    EQ              reduce using rule 33 (Relation -> Addition .)
    NEQ             reduce using rule 33 (Relation -> Addition .)
    AND             reduce using rule 33 (Relation -> Addition .)
    ;               reduce using rule 33 (Relation -> Addition .)
    OR              reduce using rule 33 (Relation -> Addition .)
    )               reduce using rule 33 (Relation -> Addition .)
    <               shift and go to state 68
    LTE             shift and go to state 69
    >               shift and go to state 70
    GTE             shift and go to state 71
    +               shift and go to state 72
    -               shift and go to state 73

    RelOp                          shift and go to state 66
    AddOp                          shift and go to state 67

state 47

    (39) Addition -> Term .
    (44) Term -> Term . MulOp Primary
    (45) MulOp -> . *
    (46) MulOp -> . /
    (47) MulOp -> . %

    <               reduce using rule 39 (Addition -> Term .)
    LTE             reduce using rule 39 (Addition -> Term .)
    >               reduce using rule 39 (Addition -> Term .)
    GTE             reduce using rule 39 (Addition -> Term .)
    +               reduce using rule 39 (Addition -> Term .)
    -               reduce using rule 39 (Addition -> Term .)
    EQ              reduce using rule 39 (Addition -> Term .)
    NEQ             reduce using rule 39 (Addition -> Term .)
    AND             reduce using rule 39 (Addition -> Term .)
    ;               reduce using rule 39 (Addition -> Term .)
    OR              reduce using rule 39 (Addition -> Term .)
    )               reduce using rule 39 (Addition -> Term .)
    *               shift and go to state 75
    /               shift and go to state 76
    %               shift and go to state 77

    MulOp                          shift and go to state 74

state 48

    (43) Term -> Factor .

    *               reduce using rule 43 (Term -> Factor .)
    /               reduce using rule 43 (Term -> Factor .)
    %               reduce using rule 43 (Term -> Factor .)
    <               reduce using rule 43 (Term -> Factor .)
    LTE             reduce using rule 43 (Term -> Factor .)
    >               reduce using rule 43 (Term -> Factor .)
    GTE             reduce using rule 43 (Term -> Factor .)
    +               reduce using rule 43 (Term -> Factor .)
    -               reduce using rule 43 (Term -> Factor .)
    EQ              reduce using rule 43 (Term -> Factor .)
    NEQ             reduce using rule 43 (Term -> Factor .)
    AND             reduce using rule 43 (Term -> Factor .)
    ;               reduce using rule 43 (Term -> Factor .)
    OR              reduce using rule 43 (Term -> Factor .)
    )               reduce using rule 43 (Term -> Factor .)


state 49

    (48) Factor -> Primary .

    *               reduce using rule 48 (Factor -> Primary .)
    /               reduce using rule 48 (Factor -> Primary .)
    %               reduce using rule 48 (Factor -> Primary .)
    <               reduce using rule 48 (Factor -> Primary .)
    LTE             reduce using rule 48 (Factor -> Primary .)
    >               reduce using rule 48 (Factor -> Primary .)
    GTE             reduce using rule 48 (Factor -> Primary .)
    +               reduce using rule 48 (Factor -> Primary .)
    -               reduce using rule 48 (Factor -> Primary .)
    EQ              reduce using rule 48 (Factor -> Primary .)
    NEQ             reduce using rule 48 (Factor -> Primary .)
    AND             reduce using rule 48 (Factor -> Primary .)
    ;               reduce using rule 48 (Factor -> Primary .)
    OR              reduce using rule 48 (Factor -> Primary .)
    )               reduce using rule 48 (Factor -> Primary .)


state 50

    (49) Factor -> UnaryOp . Primary
    (52) Primary -> . INTLIT
    (53) Primary -> . ID

    INTLIT          shift and go to state 51
    ID              shift and go to state 41

    Primary                        shift and go to state 78

state 51

    (52) Primary -> INTLIT .

    *               reduce using rule 52 (Primary -> INTLIT .)
    /               reduce using rule 52 (Primary -> INTLIT .)
    %               reduce using rule 52 (Primary -> INTLIT .)
    <               reduce using rule 52 (Primary -> INTLIT .)
    LTE             reduce using rule 52 (Primary -> INTLIT .)
    >               reduce using rule 52 (Primary -> INTLIT .)
    GTE             reduce using rule 52 (Primary -> INTLIT .)
    +               reduce using rule 52 (Primary -> INTLIT .)
    -               reduce using rule 52 (Primary -> INTLIT .)
    EQ              reduce using rule 52 (Primary -> INTLIT .)
    NEQ             reduce using rule 52 (Primary -> INTLIT .)
    AND             reduce using rule 52 (Primary -> INTLIT .)
    ;               reduce using rule 52 (Primary -> INTLIT .)
    OR              reduce using rule 52 (Primary -> INTLIT .)
    )               reduce using rule 52 (Primary -> INTLIT .)


state 52

    (50) UnaryOp -> - .

    INTLIT          reduce using rule 50 (UnaryOp -> - .)
    ID              reduce using rule 50 (UnaryOp -> - .)


state 53

    (51) UnaryOp -> ! .

    INTLIT          reduce using rule 51 (UnaryOp -> ! .)
    ID              reduce using rule 51 (UnaryOp -> ! .)


state 54

    (20) Block -> { Statements } .

    ;               reduce using rule 20 (Block -> { Statements } .)
    ID              reduce using rule 20 (Block -> { Statements } .)
    IF              reduce using rule 20 (Block -> { Statements } .)
    WHILE           reduce using rule 20 (Block -> { Statements } .)
    FOR             reduce using rule 20 (Block -> { Statements } .)
    {               reduce using rule 20 (Block -> { Statements } .)
    RETURN          reduce using rule 20 (Block -> { Statements } .)
    }               reduce using rule 20 (Block -> { Statements } .)
    ELSE            reduce using rule 20 (Block -> { Statements } .)


state 55

    (2) Function -> Type ID ( ) { Declarations Statements ReturnStatement } .

    $end            reduce using rule 2 (Function -> Type ID ( ) { Declarations Statements ReturnStatement } .)


state 56

    (3) ReturnStatement -> RETURN Expression . ;
    (26) Expression -> Expression . OR Conjunction

    ;               shift and go to state 79
    OR              shift and go to state 61


state 57

    (21) IfStatement -> IF ( Expression . ) Statement ELSE Statement
    (26) Expression -> Expression . OR Conjunction

    )               shift and go to state 80
    OR              shift and go to state 61


state 58

    (22) WhileStatement -> WHILE ( Expression . ) Statement
    (26) Expression -> Expression . OR Conjunction

    )               shift and go to state 81
    OR              shift and go to state 61


state 59

    (23) ForStatement -> FOR ( Assignment . Expression ; Assignment ) Statement
    (25) Expression -> . Conjunction
    (26) Expression -> . Expression OR Conjunction
    (27) Conjunction -> . Equality
    (28) Conjunction -> . Conjunction AND Equality
    (29) Equality -> . Relation
    (30) Equality -> . Relation EquOp Relation
    (33) Relation -> . Addition
    (34) Relation -> . Addition RelOp Addition
    (39) Addition -> . Term
    (40) Addition -> . Addition AddOp Term
    (43) Term -> . Factor
    (44) Term -> . Term MulOp Primary
    (48) Factor -> . Primary
    (49) Factor -> . UnaryOp Primary
    (52) Primary -> . INTLIT
    (53) Primary -> . ID
    (50) UnaryOp -> . -
    (51) UnaryOp -> . !

    INTLIT          shift and go to state 51
    ID              shift and go to state 41
    -               shift and go to state 52
    !               shift and go to state 53

    Expression                     shift and go to state 82
    Conjunction                    shift and go to state 43
    Equality                       shift and go to state 44
    Relation                       shift and go to state 45
    Addition                       shift and go to state 46
    Term                           shift and go to state 47
    Factor                         shift and go to state 48
    Primary                        shift and go to state 49
    UnaryOp                        shift and go to state 50

state 60

    (24) Assignment -> ID = Expression ; .

    ;               reduce using rule 24 (Assignment -> ID = Expression ; .)
    ID              reduce using rule 24 (Assignment -> ID = Expression ; .)
    IF              reduce using rule 24 (Assignment -> ID = Expression ; .)
    WHILE           reduce using rule 24 (Assignment -> ID = Expression ; .)
    FOR             reduce using rule 24 (Assignment -> ID = Expression ; .)
    {               reduce using rule 24 (Assignment -> ID = Expression ; .)
    RETURN          reduce using rule 24 (Assignment -> ID = Expression ; .)
    }               reduce using rule 24 (Assignment -> ID = Expression ; .)
    INTLIT          reduce using rule 24 (Assignment -> ID = Expression ; .)
    -               reduce using rule 24 (Assignment -> ID = Expression ; .)
    !               reduce using rule 24 (Assignment -> ID = Expression ; .)
    ELSE            reduce using rule 24 (Assignment -> ID = Expression ; .)
    )               reduce using rule 24 (Assignment -> ID = Expression ; .)


state 61

    (26) Expression -> Expression OR . Conjunction
    (27) Conjunction -> . Equality
    (28) Conjunction -> . Conjunction AND Equality
    (29) Equality -> . Relation
    (30) Equality -> . Relation EquOp Relation
    (33) Relation -> . Addition
    (34) Relation -> . Addition RelOp Addition
    (39) Addition -> . Term
    (40) Addition -> . Addition AddOp Term
    (43) Term -> . Factor
    (44) Term -> . Term MulOp Primary
    (48) Factor -> . Primary
    (49) Factor -> . UnaryOp Primary
    (52) Primary -> . INTLIT
    (53) Primary -> . ID
    (50) UnaryOp -> . -
    (51) UnaryOp -> . !

    INTLIT          shift and go to state 51
    ID              shift and go to state 41
    -               shift and go to state 52
    !               shift and go to state 53

    Conjunction                    shift and go to state 83
    Equality                       shift and go to state 44
    Relation                       shift and go to state 45
    Addition                       shift and go to state 46
    Term                           shift and go to state 47
    Factor                         shift and go to state 48
    Primary                        shift and go to state 49
    UnaryOp                        shift and go to state 50

state 62

    (28) Conjunction -> Conjunction AND . Equality
    (29) Equality -> . Relation
    (30) Equality -> . Relation EquOp Relation
    (33) Relation -> . Addition
    (34) Relation -> . Addition RelOp Addition
    (39) Addition -> . Term
    (40) Addition -> . Addition AddOp Term
    (43) Term -> . Factor
    (44) Term -> . Term MulOp Primary
    (48) Factor -> . Primary
    (49) Factor -> . UnaryOp Primary
    (52) Primary -> . INTLIT
    (53) Primary -> . ID
    (50) UnaryOp -> . -
    (51) UnaryOp -> . !

    INTLIT          shift and go to state 51
    ID              shift and go to state 41
    -               shift and go to state 52
    !               shift and go to state 53

    Equality                       shift and go to state 84
    Relation                       shift and go to state 45
    Addition                       shift and go to state 46
    Term                           shift and go to state 47
    Factor                         shift and go to state 48
    Primary                        shift and go to state 49
    UnaryOp                        shift and go to state 50

state 63

    (30) Equality -> Relation EquOp . Relation
    (33) Relation -> . Addition
    (34) Relation -> . Addition RelOp Addition
    (39) Addition -> . Term
    (40) Addition -> . Addition AddOp Term
    (43) Term -> . Factor
    (44) Term -> . Term MulOp Primary
    (48) Factor -> . Primary
    (49) Factor -> . UnaryOp Primary
    (52) Primary -> . INTLIT
    (53) Primary -> . ID
    (50) UnaryOp -> . -
    (51) UnaryOp -> . !

    INTLIT          shift and go to state 51
    ID              shift and go to state 41
    -               shift and go to state 52
    !               shift and go to state 53

    Relation                       shift and go to state 85
    Addition                       shift and go to state 46
    Term                           shift and go to state 47
    Factor                         shift and go to state 48
    Primary                        shift and go to state 49
    UnaryOp                        shift and go to state 50

state 64

    (31) EquOp -> EQ .

    INTLIT          reduce using rule 31 (EquOp -> EQ .)
    ID              reduce using rule 31 (EquOp -> EQ .)
    -               reduce using rule 31 (EquOp -> EQ .)
    !               reduce using rule 31 (EquOp -> EQ .)


state 65

    (32) EquOp -> NEQ .

    INTLIT          reduce using rule 32 (EquOp -> NEQ .)
    ID              reduce using rule 32 (EquOp -> NEQ .)
    -               reduce using rule 32 (EquOp -> NEQ .)
    !               reduce using rule 32 (EquOp -> NEQ .)


state 66

    (34) Relation -> Addition RelOp . Addition
    (39) Addition -> . Term
    (40) Addition -> . Addition AddOp Term
    (43) Term -> . Factor
    (44) Term -> . Term MulOp Primary
    (48) Factor -> . Primary
    (49) Factor -> . UnaryOp Primary
    (52) Primary -> . INTLIT
    (53) Primary -> . ID
    (50) UnaryOp -> . -
    (51) UnaryOp -> . !

    INTLIT          shift and go to state 51
    ID              shift and go to state 41
    -               shift and go to state 52
    !               shift and go to state 53

    Addition                       shift and go to state 86
    Term                           shift and go to state 47
    Factor                         shift and go to state 48
    Primary                        shift and go to state 49
    UnaryOp                        shift and go to state 50

state 67

    (40) Addition -> Addition AddOp . Term
    (43) Term -> . Factor
    (44) Term -> . Term MulOp Primary
    (48) Factor -> . Primary
    (49) Factor -> . UnaryOp Primary
    (52) Primary -> . INTLIT
    (53) Primary -> . ID
    (50) UnaryOp -> . -
    (51) UnaryOp -> . !

    INTLIT          shift and go to state 51
    ID              shift and go to state 41
    -               shift and go to state 52
    !               shift and go to state 53

    Term                           shift and go to state 87
    Factor                         shift and go to state 48
    Primary                        shift and go to state 49
    UnaryOp                        shift and go to state 50

state 68

    (35) RelOp -> < .

    INTLIT          reduce using rule 35 (RelOp -> < .)
    ID              reduce using rule 35 (RelOp -> < .)
    -               reduce using rule 35 (RelOp -> < .)
    !               reduce using rule 35 (RelOp -> < .)


state 69

    (36) RelOp -> LTE .

    INTLIT          reduce using rule 36 (RelOp -> LTE .)
    ID              reduce using rule 36 (RelOp -> LTE .)
    -               reduce using rule 36 (RelOp -> LTE .)
    !               reduce using rule 36 (RelOp -> LTE .)


state 70

    (37) RelOp -> > .

    INTLIT          reduce using rule 37 (RelOp -> > .)
    ID              reduce using rule 37 (RelOp -> > .)
    -               reduce using rule 37 (RelOp -> > .)
    !               reduce using rule 37 (RelOp -> > .)


state 71

    (38) RelOp -> GTE .

    INTLIT          reduce using rule 38 (RelOp -> GTE .)
    ID              reduce using rule 38 (RelOp -> GTE .)
    -               reduce using rule 38 (RelOp -> GTE .)
    !               reduce using rule 38 (RelOp -> GTE .)


state 72

    (41) AddOp -> + .

    INTLIT          reduce using rule 41 (AddOp -> + .)
    ID              reduce using rule 41 (AddOp -> + .)
    -               reduce using rule 41 (AddOp -> + .)
    !               reduce using rule 41 (AddOp -> + .)


state 73

    (42) AddOp -> - .

    INTLIT          reduce using rule 42 (AddOp -> - .)
    ID              reduce using rule 42 (AddOp -> - .)
    -               reduce using rule 42 (AddOp -> - .)
    !               reduce using rule 42 (AddOp -> - .)


state 74

    (44) Term -> Term MulOp . Primary
    (52) Primary -> . INTLIT
    (53) Primary -> . ID

    INTLIT          shift and go to state 51
    ID              shift and go to state 41

    Primary                        shift and go to state 88

state 75

    (45) MulOp -> * .

    INTLIT          reduce using rule 45 (MulOp -> * .)
    ID              reduce using rule 45 (MulOp -> * .)


state 76

    (46) MulOp -> / .

    INTLIT          reduce using rule 46 (MulOp -> / .)
    ID              reduce using rule 46 (MulOp -> / .)


state 77

    (47) MulOp -> % .

    INTLIT          reduce using rule 47 (MulOp -> % .)
    ID              reduce using rule 47 (MulOp -> % .)


state 78

    (49) Factor -> UnaryOp Primary .

    *               reduce using rule 49 (Factor -> UnaryOp Primary .)
    /               reduce using rule 49 (Factor -> UnaryOp Primary .)
    %               reduce using rule 49 (Factor -> UnaryOp Primary .)
    <               reduce using rule 49 (Factor -> UnaryOp Primary .)
    LTE             reduce using rule 49 (Factor -> UnaryOp Primary .)
    >               reduce using rule 49 (Factor -> UnaryOp Primary .)
    GTE             reduce using rule 49 (Factor -> UnaryOp Primary .)
    +               reduce using rule 49 (Factor -> UnaryOp Primary .)
    -               reduce using rule 49 (Factor -> UnaryOp Primary .)
    EQ              reduce using rule 49 (Factor -> UnaryOp Primary .)
    NEQ             reduce using rule 49 (Factor -> UnaryOp Primary .)
    AND             reduce using rule 49 (Factor -> UnaryOp Primary .)
    ;               reduce using rule 49 (Factor -> UnaryOp Primary .)
    OR              reduce using rule 49 (Factor -> UnaryOp Primary .)
    )               reduce using rule 49 (Factor -> UnaryOp Primary .)


state 79

    (3) ReturnStatement -> RETURN Expression ; .

    }               reduce using rule 3 (ReturnStatement -> RETURN Expression ; .)


state 80

    (21) IfStatement -> IF ( Expression ) . Statement ELSE Statement
    (14) Statement -> . Assignment
    (15) Statement -> . IfStatement
    (16) Statement -> . WhileStatement
    (17) Statement -> . ForStatement
    (18) Statement -> . ;
    (19) Statement -> . Block
    (24) Assignment -> . ID = Expression ;
    (21) IfStatement -> . IF ( Expression ) Statement ELSE Statement
    (22) WhileStatement -> . WHILE ( Expression ) Statement
    (23) ForStatement -> . FOR ( Assignment Expression ; Assignment ) Statement
    (20) Block -> . { Statements }

    ;               shift and go to state 26
    ID              shift and go to state 17
    IF              shift and go to state 28
    WHILE           shift and go to state 29
    FOR             shift and go to state 30
    {               shift and go to state 18

    Statement                      shift and go to state 89
    Assignment                     shift and go to state 22
    IfStatement                    shift and go to state 23
    WhileStatement                 shift and go to state 24
    ForStatement                   shift and go to state 25
    Block                          shift and go to state 27

state 81

    (22) WhileStatement -> WHILE ( Expression ) . Statement
    (14) Statement -> . Assignment
    (15) Statement -> . IfStatement
    (16) Statement -> . WhileStatement
    (17) Statement -> . ForStatement
    (18) Statement -> . ;
    (19) Statement -> . Block
    (24) Assignment -> . ID = Expression ;
    (21) IfStatement -> . IF ( Expression ) Statement ELSE Statement
    (22) WhileStatement -> . WHILE ( Expression ) Statement
    (23) ForStatement -> . FOR ( Assignment Expression ; Assignment ) Statement
    (20) Block -> . { Statements }

    ;               shift and go to state 26
    ID              shift and go to state 17
    IF              shift and go to state 28
    WHILE           shift and go to state 29
    FOR             shift and go to state 30
    {               shift and go to state 18

    Statement                      shift and go to state 90
    Assignment                     shift and go to state 22
    IfStatement                    shift and go to state 23
    WhileStatement                 shift and go to state 24
    ForStatement                   shift and go to state 25
    Block                          shift and go to state 27

state 82

    (23) ForStatement -> FOR ( Assignment Expression . ; Assignment ) Statement
    (26) Expression -> Expression . OR Conjunction

    ;               shift and go to state 91
    OR              shift and go to state 61


state 83

    (26) Expression -> Expression OR Conjunction .
    (28) Conjunction -> Conjunction . AND Equality

    ;               reduce using rule 26 (Expression -> Expression OR Conjunction .)
    OR              reduce using rule 26 (Expression -> Expression OR Conjunction .)
    )               reduce using rule 26 (Expression -> Expression OR Conjunction .)
    AND             shift and go to state 62


state 84

    (28) Conjunction -> Conjunction AND Equality .

    AND             reduce using rule 28 (Conjunction -> Conjunction AND Equality .)
    ;               reduce using rule 28 (Conjunction -> Conjunction AND Equality .)
    OR              reduce using rule 28 (Conjunction -> Conjunction AND Equality .)
    )               reduce using rule 28 (Conjunction -> Conjunction AND Equality .)


state 85

    (30) Equality -> Relation EquOp Relation .

    AND             reduce using rule 30 (Equality -> Relation EquOp Relation .)
    ;               reduce using rule 30 (Equality -> Relation EquOp Relation .)
    OR              reduce using rule 30 (Equality -> Relation EquOp Relation .)
    )               reduce using rule 30 (Equality -> Relation EquOp Relation .)


state 86

    (34) Relation -> Addition RelOp Addition .
    (40) Addition -> Addition . AddOp Term
    (41) AddOp -> . +
    (42) AddOp -> . -

    EQ              reduce using rule 34 (Relation -> Addition RelOp Addition .)
    NEQ             reduce using rule 34 (Relation -> Addition RelOp Addition .)
    AND             reduce using rule 34 (Relation -> Addition RelOp Addition .)
    ;               reduce using rule 34 (Relation -> Addition RelOp Addition .)
    OR              reduce using rule 34 (Relation -> Addition RelOp Addition .)
    )               reduce using rule 34 (Relation -> Addition RelOp Addition .)
    +               shift and go to state 72
    -               shift and go to state 73

    AddOp                          shift and go to state 67

state 87

    (40) Addition -> Addition AddOp Term .
    (44) Term -> Term . MulOp Primary
    (45) MulOp -> . *
    (46) MulOp -> . /
    (47) MulOp -> . %

    <               reduce using rule 40 (Addition -> Addition AddOp Term .)
    LTE             reduce using rule 40 (Addition -> Addition AddOp Term .)
    >               reduce using rule 40 (Addition -> Addition AddOp Term .)
    GTE             reduce using rule 40 (Addition -> Addition AddOp Term .)
    +               reduce using rule 40 (Addition -> Addition AddOp Term .)
    -               reduce using rule 40 (Addition -> Addition AddOp Term .)
    EQ              reduce using rule 40 (Addition -> Addition AddOp Term .)
    NEQ             reduce using rule 40 (Addition -> Addition AddOp Term .)
    AND             reduce using rule 40 (Addition -> Addition AddOp Term .)
    ;               reduce using rule 40 (Addition -> Addition AddOp Term .)
    OR              reduce using rule 40 (Addition -> Addition AddOp Term .)
    )               reduce using rule 40 (Addition -> Addition AddOp Term .)
    *               shift and go to state 75
    /               shift and go to state 76
    %               shift and go to state 77

    MulOp                          shift and go to state 74

state 88

    (44) Term -> Term MulOp Primary .

    *               reduce using rule 44 (Term -> Term MulOp Primary .)
    /               reduce using rule 44 (Term -> Term MulOp Primary .)
    %               reduce using rule 44 (Term -> Term MulOp Primary .)
    <               reduce using rule 44 (Term -> Term MulOp Primary .)
    LTE             reduce using rule 44 (Term -> Term MulOp Primary .)
    >               reduce using rule 44 (Term -> Term MulOp Primary .)
    GTE             reduce using rule 44 (Term -> Term MulOp Primary .)
    +               reduce using rule 44 (Term -> Term MulOp Primary .)
    -               reduce using rule 44 (Term -> Term MulOp Primary .)
    EQ              reduce using rule 44 (Term -> Term MulOp Primary .)
    NEQ             reduce using rule 44 (Term -> Term MulOp Primary .)
    AND             reduce using rule 44 (Term -> Term MulOp Primary .)
    ;               reduce using rule 44 (Term -> Term MulOp Primary .)
    OR              reduce using rule 44 (Term -> Term MulOp Primary .)
    )               reduce using rule 44 (Term -> Term MulOp Primary .)


state 89

    (21) IfStatement -> IF ( Expression ) Statement . ELSE Statement

    ELSE            shift and go to state 92


state 90

    (22) WhileStatement -> WHILE ( Expression ) Statement .

    ;               reduce using rule 22 (WhileStatement -> WHILE ( Expression ) Statement .)
    ID              reduce using rule 22 (WhileStatement -> WHILE ( Expression ) Statement .)
    IF              reduce using rule 22 (WhileStatement -> WHILE ( Expression ) Statement .)
    WHILE           reduce using rule 22 (WhileStatement -> WHILE ( Expression ) Statement .)
    FOR             reduce using rule 22 (WhileStatement -> WHILE ( Expression ) Statement .)
    {               reduce using rule 22 (WhileStatement -> WHILE ( Expression ) Statement .)
    RETURN          reduce using rule 22 (WhileStatement -> WHILE ( Expression ) Statement .)
    }               reduce using rule 22 (WhileStatement -> WHILE ( Expression ) Statement .)
    ELSE            reduce using rule 22 (WhileStatement -> WHILE ( Expression ) Statement .)


state 91

    (23) ForStatement -> FOR ( Assignment Expression ; . Assignment ) Statement
    (24) Assignment -> . ID = Expression ;

    ID              shift and go to state 17

    Assignment                     shift and go to state 93

state 92

    (21) IfStatement -> IF ( Expression ) Statement ELSE . Statement
    (14) Statement -> . Assignment
    (15) Statement -> . IfStatement
    (16) Statement -> . WhileStatement
    (17) Statement -> . ForStatement
    (18) Statement -> . ;
    (19) Statement -> . Block
    (24) Assignment -> . ID = Expression ;
    (21) IfStatement -> . IF ( Expression ) Statement ELSE Statement
    (22) WhileStatement -> . WHILE ( Expression ) Statement
    (23) ForStatement -> . FOR ( Assignment Expression ; Assignment ) Statement
    (20) Block -> . { Statements }

    ;               shift and go to state 26
    ID              shift and go to state 17
    IF              shift and go to state 28
    WHILE           shift and go to state 29
    FOR             shift and go to state 30
    {               shift and go to state 18

    Statement                      shift and go to state 94
    Assignment                     shift and go to state 22
    IfStatement                    shift and go to state 23
    WhileStatement                 shift and go to state 24
    ForStatement                   shift and go to state 25
    Block                          shift and go to state 27

state 93

    (23) ForStatement -> FOR ( Assignment Expression ; Assignment . ) Statement

    )               shift and go to state 95


state 94

    (21) IfStatement -> IF ( Expression ) Statement ELSE Statement .

    ;               reduce using rule 21 (IfStatement -> IF ( Expression ) Statement ELSE Statement .)
    ID              reduce using rule 21 (IfStatement -> IF ( Expression ) Statement ELSE Statement .)
    IF              reduce using rule 21 (IfStatement -> IF ( Expression ) Statement ELSE Statement .)
    WHILE           reduce using rule 21 (IfStatement -> IF ( Expression ) Statement ELSE Statement .)
    FOR             reduce using rule 21 (IfStatement -> IF ( Expression ) Statement ELSE Statement .)
    {               reduce using rule 21 (IfStatement -> IF ( Expression ) Statement ELSE Statement .)
    RETURN          reduce using rule 21 (IfStatement -> IF ( Expression ) Statement ELSE Statement .)
    }               reduce using rule 21 (IfStatement -> IF ( Expression ) Statement ELSE Statement .)
    ELSE            reduce using rule 21 (IfStatement -> IF ( Expression ) Statement ELSE Statement .)


state 95

    (23) ForStatement -> FOR ( Assignment Expression ; Assignment ) . Statement
    (14) Statement -> . Assignment
    (15) Statement -> . IfStatement
    (16) Statement -> . WhileStatement
    (17) Statement -> . ForStatement
    (18) Statement -> . ;
    (19) Statement -> . Block
    (24) Assignment -> . ID = Expression ;
    (21) IfStatement -> . IF ( Expression ) Statement ELSE Statement
    (22) WhileStatement -> . WHILE ( Expression ) Statement
    (23) ForStatement -> . FOR ( Assignment Expression ; Assignment ) Statement
    (20) Block -> . { Statements }

    ;               shift and go to state 26
    ID              shift and go to state 17
    IF              shift and go to state 28
    WHILE           shift and go to state 29
    FOR             shift and go to state 30
    {               shift and go to state 18

    Assignment                     shift and go to state 22
    Statement                      shift and go to state 96
    IfStatement                    shift and go to state 23
    WhileStatement                 shift and go to state 24
    ForStatement                   shift and go to state 25
    Block                          shift and go to state 27

state 96

    (23) ForStatement -> FOR ( Assignment Expression ; Assignment ) Statement .

    ;               reduce using rule 23 (ForStatement -> FOR ( Assignment Expression ; Assignment ) Statement .)
    ID              reduce using rule 23 (ForStatement -> FOR ( Assignment Expression ; Assignment ) Statement .)
    IF              reduce using rule 23 (ForStatement -> FOR ( Assignment Expression ; Assignment ) Statement .)
    WHILE           reduce using rule 23 (ForStatement -> FOR ( Assignment Expression ; Assignment ) Statement .)
    FOR             reduce using rule 23 (ForStatement -> FOR ( Assignment Expression ; Assignment ) Statement .)
    {               reduce using rule 23 (ForStatement -> FOR ( Assignment Expression ; Assignment ) Statement .)
    RETURN          reduce using rule 23 (ForStatement -> FOR ( Assignment Expression ; Assignment ) Statement .)
    }               reduce using rule 23 (ForStatement -> FOR ( Assignment Expression ; Assignment ) Statement .)
    ELSE            reduce using rule 23 (ForStatement -> FOR ( Assignment Expression ; Assignment ) Statement .)

