Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Unused terminals:

    FLOAT
    RETURN
    WHILE

Grammar

Rule 0     S' -> Program
Rule 1     Program -> INT MAIN ( ) { Declarations Statements }
Rule 2     empty -> <empty>
Rule 3     Declarations -> Declaration Declarations
Rule 4     Declarations -> empty
Rule 5     Declaration -> INT ID ;
Rule 6     Statements -> Statement Statements
Rule 7     Statements -> empty
Rule 8     Statement -> Assignment
Rule 9     Statement -> IfStatement
Rule 10    IfStatement -> IF ( Expression ) Statement ELSE Statement
Rule 11    Assignment -> ID = Expression ;
Rule 12    Expression -> Conjunction
Rule 13    Expression -> Expression OR Conjunction
Rule 14    Conjunction -> Equality
Rule 15    Conjunction -> Conjunction AND Equality
Rule 16    Equality -> Relation
Rule 17    Equality -> Equality EquOp Relation
Rule 18    EquOp -> EQ
Rule 19    EquOp -> NEQ
Rule 20    Relation -> Addition
Rule 21    Relation -> Relation EquOp Addition
Rule 22    RelOp -> <
Rule 23    RelOp -> LTE
Rule 24    RelOp -> >
Rule 25    RelOp -> GTE
Rule 26    Addition -> Term
Rule 27    Addition -> Addition AddOp Term
Rule 28    AddOp -> +
Rule 29    AddOp -> -
Rule 30    Term -> Factor
Rule 31    Term -> Factor MulOp Primary
Rule 32    MulOp -> *
Rule 33    MulOp -> /
Rule 34    MulOp -> %
Rule 35    Factor -> Primary
Rule 36    Factor -> UnaryOp Primary
Rule 37    UnaryOp -> -
Rule 38    UnaryOp -> !
Rule 39    Primary -> INTLIT
Rule 40    Primary -> ID

Terminals, with rules where they appear

!                    : 38
%                    : 34
(                    : 1 10
)                    : 1 10
*                    : 32
+                    : 28
-                    : 29 37
/                    : 33
;                    : 5 11
<                    : 22
=                    : 11
>                    : 24
AND                  : 15
ELSE                 : 10
EQ                   : 18
FLOAT                : 
GTE                  : 25
ID                   : 5 11 40
IF                   : 10
INT                  : 1 5
INTLIT               : 39
LTE                  : 23
MAIN                 : 1
NEQ                  : 19
OR                   : 13
RETURN               : 
WHILE                : 
error                : 
{                    : 1
}                    : 1

Nonterminals, with rules where they appear

AddOp                : 27
Addition             : 20 21 27
Assignment           : 8
Conjunction          : 12 13 15
Declaration          : 3
Declarations         : 1 3
EquOp                : 17 21
Equality             : 14 15 17
Expression           : 10 11 13
Factor               : 30 31
IfStatement          : 9
MulOp                : 31
Primary              : 31 35 36
Program              : 0
RelOp                : 
Relation             : 16 17 21
Statement            : 6 10 10
Statements           : 1 6
Term                 : 26 27
UnaryOp              : 36
empty                : 4 7

Parsing method: LALR

state 0

    (0) S' -> . Program
    (1) Program -> . INT MAIN ( ) { Declarations Statements }

    INT             shift and go to state 2

    Program                        shift and go to state 1

state 1

    (0) S' -> Program .



state 2

    (1) Program -> INT . MAIN ( ) { Declarations Statements }

    MAIN            shift and go to state 3


state 3

    (1) Program -> INT MAIN . ( ) { Declarations Statements }

    (               shift and go to state 4


state 4

    (1) Program -> INT MAIN ( . ) { Declarations Statements }

    )               shift and go to state 5


state 5

    (1) Program -> INT MAIN ( ) . { Declarations Statements }

    {               shift and go to state 6


state 6

    (1) Program -> INT MAIN ( ) { . Declarations Statements }
    (3) Declarations -> . Declaration Declarations
    (4) Declarations -> . empty
    (5) Declaration -> . INT ID ;
    (2) empty -> .

    INT             shift and go to state 7
    ID              reduce using rule 2 (empty -> .)
    IF              reduce using rule 2 (empty -> .)
    }               reduce using rule 2 (empty -> .)

    Declarations                   shift and go to state 8
    Declaration                    shift and go to state 9
    empty                          shift and go to state 10

state 7

    (5) Declaration -> INT . ID ;

    ID              shift and go to state 11


state 8

    (1) Program -> INT MAIN ( ) { Declarations . Statements }
    (6) Statements -> . Statement Statements
    (7) Statements -> . empty
    (8) Statement -> . Assignment
    (9) Statement -> . IfStatement
    (2) empty -> .
    (11) Assignment -> . ID = Expression ;
    (10) IfStatement -> . IF ( Expression ) Statement ELSE Statement

    }               reduce using rule 2 (empty -> .)
    ID              shift and go to state 17
    IF              shift and go to state 18

    Statements                     shift and go to state 12
    Statement                      shift and go to state 13
    empty                          shift and go to state 14
    Assignment                     shift and go to state 15
    IfStatement                    shift and go to state 16

state 9

    (3) Declarations -> Declaration . Declarations
    (3) Declarations -> . Declaration Declarations
    (4) Declarations -> . empty
    (5) Declaration -> . INT ID ;
    (2) empty -> .

    INT             shift and go to state 7
    ID              reduce using rule 2 (empty -> .)
    IF              reduce using rule 2 (empty -> .)
    }               reduce using rule 2 (empty -> .)

    Declaration                    shift and go to state 9
    Declarations                   shift and go to state 19
    empty                          shift and go to state 10

state 10

    (4) Declarations -> empty .

    ID              reduce using rule 4 (Declarations -> empty .)
    IF              reduce using rule 4 (Declarations -> empty .)
    }               reduce using rule 4 (Declarations -> empty .)


state 11

    (5) Declaration -> INT ID . ;

    ;               shift and go to state 20


state 12

    (1) Program -> INT MAIN ( ) { Declarations Statements . }

    }               shift and go to state 21


state 13

    (6) Statements -> Statement . Statements
    (6) Statements -> . Statement Statements
    (7) Statements -> . empty
    (8) Statement -> . Assignment
    (9) Statement -> . IfStatement
    (2) empty -> .
    (11) Assignment -> . ID = Expression ;
    (10) IfStatement -> . IF ( Expression ) Statement ELSE Statement

    }               reduce using rule 2 (empty -> .)
    ID              shift and go to state 17
    IF              shift and go to state 18

    Statement                      shift and go to state 13
    Statements                     shift and go to state 22
    empty                          shift and go to state 14
    Assignment                     shift and go to state 15
    IfStatement                    shift and go to state 16

state 14

    (7) Statements -> empty .

    }               reduce using rule 7 (Statements -> empty .)


state 15

    (8) Statement -> Assignment .

    ID              reduce using rule 8 (Statement -> Assignment .)
    IF              reduce using rule 8 (Statement -> Assignment .)
    }               reduce using rule 8 (Statement -> Assignment .)
    ELSE            reduce using rule 8 (Statement -> Assignment .)


state 16

    (9) Statement -> IfStatement .

    ID              reduce using rule 9 (Statement -> IfStatement .)
    IF              reduce using rule 9 (Statement -> IfStatement .)
    }               reduce using rule 9 (Statement -> IfStatement .)
    ELSE            reduce using rule 9 (Statement -> IfStatement .)


state 17

    (11) Assignment -> ID . = Expression ;

    =               shift and go to state 23


state 18

    (10) IfStatement -> IF . ( Expression ) Statement ELSE Statement

    (               shift and go to state 24


state 19

    (3) Declarations -> Declaration Declarations .

    ID              reduce using rule 3 (Declarations -> Declaration Declarations .)
    IF              reduce using rule 3 (Declarations -> Declaration Declarations .)
    }               reduce using rule 3 (Declarations -> Declaration Declarations .)


state 20

    (5) Declaration -> INT ID ; .

    INT             reduce using rule 5 (Declaration -> INT ID ; .)
    ID              reduce using rule 5 (Declaration -> INT ID ; .)
    IF              reduce using rule 5 (Declaration -> INT ID ; .)
    }               reduce using rule 5 (Declaration -> INT ID ; .)


state 21

    (1) Program -> INT MAIN ( ) { Declarations Statements } .

    $end            reduce using rule 1 (Program -> INT MAIN ( ) { Declarations Statements } .)


state 22

    (6) Statements -> Statement Statements .

    }               reduce using rule 6 (Statements -> Statement Statements .)


state 23

    (11) Assignment -> ID = . Expression ;
    (12) Expression -> . Conjunction
    (13) Expression -> . Expression OR Conjunction
    (14) Conjunction -> . Equality
    (15) Conjunction -> . Conjunction AND Equality
    (16) Equality -> . Relation
    (17) Equality -> . Equality EquOp Relation
    (20) Relation -> . Addition
    (21) Relation -> . Relation EquOp Addition
    (26) Addition -> . Term
    (27) Addition -> . Addition AddOp Term
    (30) Term -> . Factor
    (31) Term -> . Factor MulOp Primary
    (35) Factor -> . Primary
    (36) Factor -> . UnaryOp Primary
    (39) Primary -> . INTLIT
    (40) Primary -> . ID
    (37) UnaryOp -> . -
    (38) UnaryOp -> . !

    INTLIT          shift and go to state 35
    ID              shift and go to state 25
    -               shift and go to state 36
    !               shift and go to state 37

    Expression                     shift and go to state 26
    Conjunction                    shift and go to state 27
    Equality                       shift and go to state 28
    Relation                       shift and go to state 29
    Addition                       shift and go to state 30
    Term                           shift and go to state 31
    Factor                         shift and go to state 32
    Primary                        shift and go to state 33
    UnaryOp                        shift and go to state 34

state 24

    (10) IfStatement -> IF ( . Expression ) Statement ELSE Statement
    (12) Expression -> . Conjunction
    (13) Expression -> . Expression OR Conjunction
    (14) Conjunction -> . Equality
    (15) Conjunction -> . Conjunction AND Equality
    (16) Equality -> . Relation
    (17) Equality -> . Equality EquOp Relation
    (20) Relation -> . Addition
    (21) Relation -> . Relation EquOp Addition
    (26) Addition -> . Term
    (27) Addition -> . Addition AddOp Term
    (30) Term -> . Factor
    (31) Term -> . Factor MulOp Primary
    (35) Factor -> . Primary
    (36) Factor -> . UnaryOp Primary
    (39) Primary -> . INTLIT
    (40) Primary -> . ID
    (37) UnaryOp -> . -
    (38) UnaryOp -> . !

    INTLIT          shift and go to state 35
    ID              shift and go to state 25
    -               shift and go to state 36
    !               shift and go to state 37

    Expression                     shift and go to state 38
    Conjunction                    shift and go to state 27
    Equality                       shift and go to state 28
    Relation                       shift and go to state 29
    Addition                       shift and go to state 30
    Term                           shift and go to state 31
    Factor                         shift and go to state 32
    Primary                        shift and go to state 33
    UnaryOp                        shift and go to state 34

state 25

    (40) Primary -> ID .

    *               reduce using rule 40 (Primary -> ID .)
    /               reduce using rule 40 (Primary -> ID .)
    %               reduce using rule 40 (Primary -> ID .)
    +               reduce using rule 40 (Primary -> ID .)
    -               reduce using rule 40 (Primary -> ID .)
    EQ              reduce using rule 40 (Primary -> ID .)
    NEQ             reduce using rule 40 (Primary -> ID .)
    AND             reduce using rule 40 (Primary -> ID .)
    ;               reduce using rule 40 (Primary -> ID .)
    OR              reduce using rule 40 (Primary -> ID .)
    )               reduce using rule 40 (Primary -> ID .)


state 26

    (11) Assignment -> ID = Expression . ;
    (13) Expression -> Expression . OR Conjunction

    ;               shift and go to state 39
    OR              shift and go to state 40


state 27

    (12) Expression -> Conjunction .
    (15) Conjunction -> Conjunction . AND Equality

    ;               reduce using rule 12 (Expression -> Conjunction .)
    OR              reduce using rule 12 (Expression -> Conjunction .)
    )               reduce using rule 12 (Expression -> Conjunction .)
    AND             shift and go to state 41


state 28

    (14) Conjunction -> Equality .
    (17) Equality -> Equality . EquOp Relation
    (18) EquOp -> . EQ
    (19) EquOp -> . NEQ

    AND             reduce using rule 14 (Conjunction -> Equality .)
    ;               reduce using rule 14 (Conjunction -> Equality .)
    OR              reduce using rule 14 (Conjunction -> Equality .)
    )               reduce using rule 14 (Conjunction -> Equality .)
    EQ              shift and go to state 43
    NEQ             shift and go to state 44

    EquOp                          shift and go to state 42

state 29

    (16) Equality -> Relation .
    (21) Relation -> Relation . EquOp Addition
    (18) EquOp -> . EQ
    (19) EquOp -> . NEQ

  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
    AND             reduce using rule 16 (Equality -> Relation .)
    ;               reduce using rule 16 (Equality -> Relation .)
    OR              reduce using rule 16 (Equality -> Relation .)
    )               reduce using rule 16 (Equality -> Relation .)
    EQ              shift and go to state 43
    NEQ             shift and go to state 44

  ! EQ              [ reduce using rule 16 (Equality -> Relation .) ]
  ! NEQ             [ reduce using rule 16 (Equality -> Relation .) ]

    EquOp                          shift and go to state 45

state 30

    (20) Relation -> Addition .
    (27) Addition -> Addition . AddOp Term
    (28) AddOp -> . +
    (29) AddOp -> . -

    EQ              reduce using rule 20 (Relation -> Addition .)
    NEQ             reduce using rule 20 (Relation -> Addition .)
    AND             reduce using rule 20 (Relation -> Addition .)
    ;               reduce using rule 20 (Relation -> Addition .)
    OR              reduce using rule 20 (Relation -> Addition .)
    )               reduce using rule 20 (Relation -> Addition .)
    +               shift and go to state 47
    -               shift and go to state 48

    AddOp                          shift and go to state 46

state 31

    (26) Addition -> Term .

    +               reduce using rule 26 (Addition -> Term .)
    -               reduce using rule 26 (Addition -> Term .)
    EQ              reduce using rule 26 (Addition -> Term .)
    NEQ             reduce using rule 26 (Addition -> Term .)
    AND             reduce using rule 26 (Addition -> Term .)
    ;               reduce using rule 26 (Addition -> Term .)
    OR              reduce using rule 26 (Addition -> Term .)
    )               reduce using rule 26 (Addition -> Term .)


state 32

    (30) Term -> Factor .
    (31) Term -> Factor . MulOp Primary
    (32) MulOp -> . *
    (33) MulOp -> . /
    (34) MulOp -> . %

    +               reduce using rule 30 (Term -> Factor .)
    -               reduce using rule 30 (Term -> Factor .)
    EQ              reduce using rule 30 (Term -> Factor .)
    NEQ             reduce using rule 30 (Term -> Factor .)
    AND             reduce using rule 30 (Term -> Factor .)
    ;               reduce using rule 30 (Term -> Factor .)
    OR              reduce using rule 30 (Term -> Factor .)
    )               reduce using rule 30 (Term -> Factor .)
    *               shift and go to state 50
    /               shift and go to state 51
    %               shift and go to state 52

    MulOp                          shift and go to state 49

state 33

    (35) Factor -> Primary .

    *               reduce using rule 35 (Factor -> Primary .)
    /               reduce using rule 35 (Factor -> Primary .)
    %               reduce using rule 35 (Factor -> Primary .)
    +               reduce using rule 35 (Factor -> Primary .)
    -               reduce using rule 35 (Factor -> Primary .)
    EQ              reduce using rule 35 (Factor -> Primary .)
    NEQ             reduce using rule 35 (Factor -> Primary .)
    AND             reduce using rule 35 (Factor -> Primary .)
    ;               reduce using rule 35 (Factor -> Primary .)
    OR              reduce using rule 35 (Factor -> Primary .)
    )               reduce using rule 35 (Factor -> Primary .)


state 34

    (36) Factor -> UnaryOp . Primary
    (39) Primary -> . INTLIT
    (40) Primary -> . ID

    INTLIT          shift and go to state 35
    ID              shift and go to state 25

    Primary                        shift and go to state 53

state 35

    (39) Primary -> INTLIT .

    *               reduce using rule 39 (Primary -> INTLIT .)
    /               reduce using rule 39 (Primary -> INTLIT .)
    %               reduce using rule 39 (Primary -> INTLIT .)
    +               reduce using rule 39 (Primary -> INTLIT .)
    -               reduce using rule 39 (Primary -> INTLIT .)
    EQ              reduce using rule 39 (Primary -> INTLIT .)
    NEQ             reduce using rule 39 (Primary -> INTLIT .)
    AND             reduce using rule 39 (Primary -> INTLIT .)
    ;               reduce using rule 39 (Primary -> INTLIT .)
    OR              reduce using rule 39 (Primary -> INTLIT .)
    )               reduce using rule 39 (Primary -> INTLIT .)


state 36

    (37) UnaryOp -> - .

    INTLIT          reduce using rule 37 (UnaryOp -> - .)
    ID              reduce using rule 37 (UnaryOp -> - .)


state 37

    (38) UnaryOp -> ! .

    INTLIT          reduce using rule 38 (UnaryOp -> ! .)
    ID              reduce using rule 38 (UnaryOp -> ! .)


state 38

    (10) IfStatement -> IF ( Expression . ) Statement ELSE Statement
    (13) Expression -> Expression . OR Conjunction

    )               shift and go to state 54
    OR              shift and go to state 40


state 39

    (11) Assignment -> ID = Expression ; .

    ID              reduce using rule 11 (Assignment -> ID = Expression ; .)
    IF              reduce using rule 11 (Assignment -> ID = Expression ; .)
    }               reduce using rule 11 (Assignment -> ID = Expression ; .)
    ELSE            reduce using rule 11 (Assignment -> ID = Expression ; .)


state 40

    (13) Expression -> Expression OR . Conjunction
    (14) Conjunction -> . Equality
    (15) Conjunction -> . Conjunction AND Equality
    (16) Equality -> . Relation
    (17) Equality -> . Equality EquOp Relation
    (20) Relation -> . Addition
    (21) Relation -> . Relation EquOp Addition
    (26) Addition -> . Term
    (27) Addition -> . Addition AddOp Term
    (30) Term -> . Factor
    (31) Term -> . Factor MulOp Primary
    (35) Factor -> . Primary
    (36) Factor -> . UnaryOp Primary
    (39) Primary -> . INTLIT
    (40) Primary -> . ID
    (37) UnaryOp -> . -
    (38) UnaryOp -> . !

    INTLIT          shift and go to state 35
    ID              shift and go to state 25
    -               shift and go to state 36
    !               shift and go to state 37

    Conjunction                    shift and go to state 55
    Equality                       shift and go to state 28
    Relation                       shift and go to state 29
    Addition                       shift and go to state 30
    Term                           shift and go to state 31
    Factor                         shift and go to state 32
    Primary                        shift and go to state 33
    UnaryOp                        shift and go to state 34

state 41

    (15) Conjunction -> Conjunction AND . Equality
    (16) Equality -> . Relation
    (17) Equality -> . Equality EquOp Relation
    (20) Relation -> . Addition
    (21) Relation -> . Relation EquOp Addition
    (26) Addition -> . Term
    (27) Addition -> . Addition AddOp Term
    (30) Term -> . Factor
    (31) Term -> . Factor MulOp Primary
    (35) Factor -> . Primary
    (36) Factor -> . UnaryOp Primary
    (39) Primary -> . INTLIT
    (40) Primary -> . ID
    (37) UnaryOp -> . -
    (38) UnaryOp -> . !

    INTLIT          shift and go to state 35
    ID              shift and go to state 25
    -               shift and go to state 36
    !               shift and go to state 37

    Equality                       shift and go to state 56
    Relation                       shift and go to state 29
    Addition                       shift and go to state 30
    Term                           shift and go to state 31
    Factor                         shift and go to state 32
    Primary                        shift and go to state 33
    UnaryOp                        shift and go to state 34

state 42

    (17) Equality -> Equality EquOp . Relation
    (20) Relation -> . Addition
    (21) Relation -> . Relation EquOp Addition
    (26) Addition -> . Term
    (27) Addition -> . Addition AddOp Term
    (30) Term -> . Factor
    (31) Term -> . Factor MulOp Primary
    (35) Factor -> . Primary
    (36) Factor -> . UnaryOp Primary
    (39) Primary -> . INTLIT
    (40) Primary -> . ID
    (37) UnaryOp -> . -
    (38) UnaryOp -> . !

    INTLIT          shift and go to state 35
    ID              shift and go to state 25
    -               shift and go to state 36
    !               shift and go to state 37

    Relation                       shift and go to state 57
    Addition                       shift and go to state 30
    Term                           shift and go to state 31
    Factor                         shift and go to state 32
    Primary                        shift and go to state 33
    UnaryOp                        shift and go to state 34

state 43

    (18) EquOp -> EQ .

    INTLIT          reduce using rule 18 (EquOp -> EQ .)
    ID              reduce using rule 18 (EquOp -> EQ .)
    -               reduce using rule 18 (EquOp -> EQ .)
    !               reduce using rule 18 (EquOp -> EQ .)


state 44

    (19) EquOp -> NEQ .

    INTLIT          reduce using rule 19 (EquOp -> NEQ .)
    ID              reduce using rule 19 (EquOp -> NEQ .)
    -               reduce using rule 19 (EquOp -> NEQ .)
    !               reduce using rule 19 (EquOp -> NEQ .)


state 45

    (21) Relation -> Relation EquOp . Addition
    (26) Addition -> . Term
    (27) Addition -> . Addition AddOp Term
    (30) Term -> . Factor
    (31) Term -> . Factor MulOp Primary
    (35) Factor -> . Primary
    (36) Factor -> . UnaryOp Primary
    (39) Primary -> . INTLIT
    (40) Primary -> . ID
    (37) UnaryOp -> . -
    (38) UnaryOp -> . !

    INTLIT          shift and go to state 35
    ID              shift and go to state 25
    -               shift and go to state 36
    !               shift and go to state 37

    Addition                       shift and go to state 58
    Term                           shift and go to state 31
    Factor                         shift and go to state 32
    Primary                        shift and go to state 33
    UnaryOp                        shift and go to state 34

state 46

    (27) Addition -> Addition AddOp . Term
    (30) Term -> . Factor
    (31) Term -> . Factor MulOp Primary
    (35) Factor -> . Primary
    (36) Factor -> . UnaryOp Primary
    (39) Primary -> . INTLIT
    (40) Primary -> . ID
    (37) UnaryOp -> . -
    (38) UnaryOp -> . !

    INTLIT          shift and go to state 35
    ID              shift and go to state 25
    -               shift and go to state 36
    !               shift and go to state 37

    Term                           shift and go to state 59
    Factor                         shift and go to state 32
    Primary                        shift and go to state 33
    UnaryOp                        shift and go to state 34

state 47

    (28) AddOp -> + .

    INTLIT          reduce using rule 28 (AddOp -> + .)
    ID              reduce using rule 28 (AddOp -> + .)
    -               reduce using rule 28 (AddOp -> + .)
    !               reduce using rule 28 (AddOp -> + .)


state 48

    (29) AddOp -> - .

    INTLIT          reduce using rule 29 (AddOp -> - .)
    ID              reduce using rule 29 (AddOp -> - .)
    -               reduce using rule 29 (AddOp -> - .)
    !               reduce using rule 29 (AddOp -> - .)


state 49

    (31) Term -> Factor MulOp . Primary
    (39) Primary -> . INTLIT
    (40) Primary -> . ID

    INTLIT          shift and go to state 35
    ID              shift and go to state 25

    Primary                        shift and go to state 60

state 50

    (32) MulOp -> * .

    INTLIT          reduce using rule 32 (MulOp -> * .)
    ID              reduce using rule 32 (MulOp -> * .)


state 51

    (33) MulOp -> / .

    INTLIT          reduce using rule 33 (MulOp -> / .)
    ID              reduce using rule 33 (MulOp -> / .)


state 52

    (34) MulOp -> % .

    INTLIT          reduce using rule 34 (MulOp -> % .)
    ID              reduce using rule 34 (MulOp -> % .)


state 53

    (36) Factor -> UnaryOp Primary .

    *               reduce using rule 36 (Factor -> UnaryOp Primary .)
    /               reduce using rule 36 (Factor -> UnaryOp Primary .)
    %               reduce using rule 36 (Factor -> UnaryOp Primary .)
    +               reduce using rule 36 (Factor -> UnaryOp Primary .)
    -               reduce using rule 36 (Factor -> UnaryOp Primary .)
    EQ              reduce using rule 36 (Factor -> UnaryOp Primary .)
    NEQ             reduce using rule 36 (Factor -> UnaryOp Primary .)
    AND             reduce using rule 36 (Factor -> UnaryOp Primary .)
    ;               reduce using rule 36 (Factor -> UnaryOp Primary .)
    OR              reduce using rule 36 (Factor -> UnaryOp Primary .)
    )               reduce using rule 36 (Factor -> UnaryOp Primary .)


state 54

    (10) IfStatement -> IF ( Expression ) . Statement ELSE Statement
    (8) Statement -> . Assignment
    (9) Statement -> . IfStatement
    (11) Assignment -> . ID = Expression ;
    (10) IfStatement -> . IF ( Expression ) Statement ELSE Statement

    ID              shift and go to state 17
    IF              shift and go to state 18

    Statement                      shift and go to state 61
    Assignment                     shift and go to state 15
    IfStatement                    shift and go to state 16

state 55

    (13) Expression -> Expression OR Conjunction .
    (15) Conjunction -> Conjunction . AND Equality

    ;               reduce using rule 13 (Expression -> Expression OR Conjunction .)
    OR              reduce using rule 13 (Expression -> Expression OR Conjunction .)
    )               reduce using rule 13 (Expression -> Expression OR Conjunction .)
    AND             shift and go to state 41


state 56

    (15) Conjunction -> Conjunction AND Equality .
    (17) Equality -> Equality . EquOp Relation
    (18) EquOp -> . EQ
    (19) EquOp -> . NEQ

    AND             reduce using rule 15 (Conjunction -> Conjunction AND Equality .)
    ;               reduce using rule 15 (Conjunction -> Conjunction AND Equality .)
    OR              reduce using rule 15 (Conjunction -> Conjunction AND Equality .)
    )               reduce using rule 15 (Conjunction -> Conjunction AND Equality .)
    EQ              shift and go to state 43
    NEQ             shift and go to state 44

    EquOp                          shift and go to state 42

state 57

    (17) Equality -> Equality EquOp Relation .
    (21) Relation -> Relation . EquOp Addition
    (18) EquOp -> . EQ
    (19) EquOp -> . NEQ

  ! shift/reduce conflict for EQ resolved as shift
  ! shift/reduce conflict for NEQ resolved as shift
    AND             reduce using rule 17 (Equality -> Equality EquOp Relation .)
    ;               reduce using rule 17 (Equality -> Equality EquOp Relation .)
    OR              reduce using rule 17 (Equality -> Equality EquOp Relation .)
    )               reduce using rule 17 (Equality -> Equality EquOp Relation .)
    EQ              shift and go to state 43
    NEQ             shift and go to state 44

  ! EQ              [ reduce using rule 17 (Equality -> Equality EquOp Relation .) ]
  ! NEQ             [ reduce using rule 17 (Equality -> Equality EquOp Relation .) ]

    EquOp                          shift and go to state 45

state 58

    (21) Relation -> Relation EquOp Addition .
    (27) Addition -> Addition . AddOp Term
    (28) AddOp -> . +
    (29) AddOp -> . -

    EQ              reduce using rule 21 (Relation -> Relation EquOp Addition .)
    NEQ             reduce using rule 21 (Relation -> Relation EquOp Addition .)
    AND             reduce using rule 21 (Relation -> Relation EquOp Addition .)
    ;               reduce using rule 21 (Relation -> Relation EquOp Addition .)
    OR              reduce using rule 21 (Relation -> Relation EquOp Addition .)
    )               reduce using rule 21 (Relation -> Relation EquOp Addition .)
    +               shift and go to state 47
    -               shift and go to state 48

    AddOp                          shift and go to state 46

state 59

    (27) Addition -> Addition AddOp Term .

    +               reduce using rule 27 (Addition -> Addition AddOp Term .)
    -               reduce using rule 27 (Addition -> Addition AddOp Term .)
    EQ              reduce using rule 27 (Addition -> Addition AddOp Term .)
    NEQ             reduce using rule 27 (Addition -> Addition AddOp Term .)
    AND             reduce using rule 27 (Addition -> Addition AddOp Term .)
    ;               reduce using rule 27 (Addition -> Addition AddOp Term .)
    OR              reduce using rule 27 (Addition -> Addition AddOp Term .)
    )               reduce using rule 27 (Addition -> Addition AddOp Term .)


state 60

    (31) Term -> Factor MulOp Primary .

    +               reduce using rule 31 (Term -> Factor MulOp Primary .)
    -               reduce using rule 31 (Term -> Factor MulOp Primary .)
    EQ              reduce using rule 31 (Term -> Factor MulOp Primary .)
    NEQ             reduce using rule 31 (Term -> Factor MulOp Primary .)
    AND             reduce using rule 31 (Term -> Factor MulOp Primary .)
    ;               reduce using rule 31 (Term -> Factor MulOp Primary .)
    OR              reduce using rule 31 (Term -> Factor MulOp Primary .)
    )               reduce using rule 31 (Term -> Factor MulOp Primary .)


state 61

    (10) IfStatement -> IF ( Expression ) Statement . ELSE Statement

    ELSE            shift and go to state 62


state 62

    (10) IfStatement -> IF ( Expression ) Statement ELSE . Statement
    (8) Statement -> . Assignment
    (9) Statement -> . IfStatement
    (11) Assignment -> . ID = Expression ;
    (10) IfStatement -> . IF ( Expression ) Statement ELSE Statement

    ID              shift and go to state 17
    IF              shift and go to state 18

    Statement                      shift and go to state 63
    Assignment                     shift and go to state 15
    IfStatement                    shift and go to state 16

state 63

    (10) IfStatement -> IF ( Expression ) Statement ELSE Statement .

    ID              reduce using rule 10 (IfStatement -> IF ( Expression ) Statement ELSE Statement .)
    IF              reduce using rule 10 (IfStatement -> IF ( Expression ) Statement ELSE Statement .)
    }               reduce using rule 10 (IfStatement -> IF ( Expression ) Statement ELSE Statement .)
    ELSE            reduce using rule 10 (IfStatement -> IF ( Expression ) Statement ELSE Statement .)

WARNING: 
WARNING: Conflicts:
WARNING: 
WARNING: shift/reduce conflict for EQ in state 29 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 29 resolved as shift
WARNING: shift/reduce conflict for EQ in state 57 resolved as shift
WARNING: shift/reduce conflict for NEQ in state 57 resolved as shift
