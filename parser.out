Created by PLY version 3.11 (http://www.dabeaz.com/ply)

Grammar

Rule 0     S' -> Program
Rule 1     Program -> Function Program
Rule 2     Program -> empty
Rule 3     Function -> FunctionReturnType ID ( ) { Declarations Statements ReturnStatement }
Rule 4     ReturnStatement -> RETURN Expression ;
Rule 5     ReturnStatement -> RETURN ;
Rule 6     empty -> <empty>
Rule 7     Declarations -> Declaration Declarations
Rule 8     Declarations -> empty
Rule 9     Declaration -> Type ID ;
Rule 10    Type -> INT
Rule 11    Type -> BOOL
Rule 12    Type -> FLOAT
Rule 13    Type -> CHAR
Rule 14    FunctionReturnType -> Type
Rule 15    FunctionReturnType -> VOID
Rule 16    Statements -> Statement Statements
Rule 17    Statements -> empty
Rule 18    Statement -> Assignment
Rule 19    Statement -> IfStatement
Rule 20    Statement -> WhileStatement
Rule 21    Statement -> ForStatement
Rule 22    Statement -> ;
Rule 23    Statement -> Block
Rule 24    Block -> { Statements }
Rule 25    IfStatement -> IF ( Expression ) Statement ELSE Statement
Rule 26    WhileStatement -> WHILE ( Expression ) Statement
Rule 27    ForStatement -> FOR ( Assignment Expression ; Assignment ) Statement
Rule 28    Assignment -> ID = Expression ;
Rule 29    Expression -> Conjunction
Rule 30    Expression -> Expression OR Conjunction
Rule 31    Conjunction -> Equality
Rule 32    Conjunction -> Conjunction AND Equality
Rule 33    Equality -> Relation
Rule 34    Equality -> Relation EquOp Relation
Rule 35    EquOp -> EQ
Rule 36    EquOp -> NEQ
Rule 37    Relation -> Addition
Rule 38    Relation -> Addition RelOp Addition
Rule 39    RelOp -> <
Rule 40    RelOp -> LTE
Rule 41    RelOp -> >
Rule 42    RelOp -> GTE
Rule 43    Addition -> Term
Rule 44    Addition -> Addition AddOp Term
Rule 45    AddOp -> +
Rule 46    AddOp -> -
Rule 47    Term -> Factor
Rule 48    Term -> Term MulOp Primary
Rule 49    MulOp -> *
Rule 50    MulOp -> /
Rule 51    MulOp -> %
Rule 52    Factor -> Primary
Rule 53    Factor -> UnaryOp Primary
Rule 54    UnaryOp -> -
Rule 55    UnaryOp -> !
Rule 56    Primary -> INTLIT
Rule 57    Primary -> ID
Rule 58    Primary -> ID ( )

Terminals, with rules where they appear

!                    : 55
%                    : 51
(                    : 3 25 26 27 58
)                    : 3 25 26 27 58
*                    : 49
+                    : 45
-                    : 46 54
/                    : 50
;                    : 4 5 9 22 27 28
<                    : 39
=                    : 28
>                    : 41
AND                  : 32
BOOL                 : 11
CHAR                 : 13
ELSE                 : 25
EQ                   : 35
FLOAT                : 12
FOR                  : 27
GTE                  : 42
ID                   : 3 9 28 57 58
IF                   : 25
INT                  : 10
INTLIT               : 56
LTE                  : 40
NEQ                  : 36
OR                   : 30
RETURN               : 4 5
VOID                 : 15
WHILE                : 26
error                : 
{                    : 3 24
}                    : 3 24

Nonterminals, with rules where they appear

AddOp                : 44
Addition             : 37 38 38 44
Assignment           : 18 27 27
Block                : 23
Conjunction          : 29 30 32
Declaration          : 7
Declarations         : 3 7
EquOp                : 34
Equality             : 31 32
Expression           : 4 25 26 27 28 30
Factor               : 47
ForStatement         : 21
Function             : 1
FunctionReturnType   : 3
IfStatement          : 19
MulOp                : 48
Primary              : 48 52 53
Program              : 1 0
RelOp                : 38
Relation             : 33 34 34
ReturnStatement      : 3
Statement            : 16 25 25 26 27
Statements           : 3 16 24
Term                 : 43 44 48
Type                 : 9 14
UnaryOp              : 53
WhileStatement       : 20
empty                : 2 8 17

Parsing method: LALR

state 0

    (0) S' -> . Program
    (1) Program -> . Function Program
    (2) Program -> . empty
    (3) Function -> . FunctionReturnType ID ( ) { Declarations Statements ReturnStatement }
    (6) empty -> .
    (14) FunctionReturnType -> . Type
    (15) FunctionReturnType -> . VOID
    (10) Type -> . INT
    (11) Type -> . BOOL
    (12) Type -> . FLOAT
    (13) Type -> . CHAR

    $end            reduce using rule 6 (empty -> .)
    VOID            shift and go to state 6
    INT             shift and go to state 7
    BOOL            shift and go to state 8
    FLOAT           shift and go to state 9
    CHAR            shift and go to state 10

    Program                        shift and go to state 1
    Function                       shift and go to state 2
    empty                          shift and go to state 3
    FunctionReturnType             shift and go to state 4
    Type                           shift and go to state 5

state 1

    (0) S' -> Program .



state 2

    (1) Program -> Function . Program
    (1) Program -> . Function Program
    (2) Program -> . empty
    (3) Function -> . FunctionReturnType ID ( ) { Declarations Statements ReturnStatement }
    (6) empty -> .
    (14) FunctionReturnType -> . Type
    (15) FunctionReturnType -> . VOID
    (10) Type -> . INT
    (11) Type -> . BOOL
    (12) Type -> . FLOAT
    (13) Type -> . CHAR

    $end            reduce using rule 6 (empty -> .)
    VOID            shift and go to state 6
    INT             shift and go to state 7
    BOOL            shift and go to state 8
    FLOAT           shift and go to state 9
    CHAR            shift and go to state 10

    Function                       shift and go to state 2
    Program                        shift and go to state 11
    empty                          shift and go to state 3
    FunctionReturnType             shift and go to state 4
    Type                           shift and go to state 5

state 3

    (2) Program -> empty .

    $end            reduce using rule 2 (Program -> empty .)


state 4

    (3) Function -> FunctionReturnType . ID ( ) { Declarations Statements ReturnStatement }

    ID              shift and go to state 12


state 5

    (14) FunctionReturnType -> Type .

    ID              reduce using rule 14 (FunctionReturnType -> Type .)


state 6

    (15) FunctionReturnType -> VOID .

    ID              reduce using rule 15 (FunctionReturnType -> VOID .)


state 7

    (10) Type -> INT .

    ID              reduce using rule 10 (Type -> INT .)


state 8

    (11) Type -> BOOL .

    ID              reduce using rule 11 (Type -> BOOL .)


state 9

    (12) Type -> FLOAT .

    ID              reduce using rule 12 (Type -> FLOAT .)


state 10

    (13) Type -> CHAR .

    ID              reduce using rule 13 (Type -> CHAR .)


state 11

    (1) Program -> Function Program .

    $end            reduce using rule 1 (Program -> Function Program .)


state 12

    (3) Function -> FunctionReturnType ID . ( ) { Declarations Statements ReturnStatement }

    (               shift and go to state 13


state 13

    (3) Function -> FunctionReturnType ID ( . ) { Declarations Statements ReturnStatement }

    )               shift and go to state 14


state 14

    (3) Function -> FunctionReturnType ID ( ) . { Declarations Statements ReturnStatement }

    {               shift and go to state 15


state 15

    (3) Function -> FunctionReturnType ID ( ) { . Declarations Statements ReturnStatement }
    (7) Declarations -> . Declaration Declarations
    (8) Declarations -> . empty
    (9) Declaration -> . Type ID ;
    (6) empty -> .
    (10) Type -> . INT
    (11) Type -> . BOOL
    (12) Type -> . FLOAT
    (13) Type -> . CHAR

    ;               reduce using rule 6 (empty -> .)
    ID              reduce using rule 6 (empty -> .)
    IF              reduce using rule 6 (empty -> .)
    WHILE           reduce using rule 6 (empty -> .)
    FOR             reduce using rule 6 (empty -> .)
    {               reduce using rule 6 (empty -> .)
    RETURN          reduce using rule 6 (empty -> .)
    INT             shift and go to state 7
    BOOL            shift and go to state 8
    FLOAT           shift and go to state 9
    CHAR            shift and go to state 10

    Declarations                   shift and go to state 16
    Declaration                    shift and go to state 17
    empty                          shift and go to state 18
    Type                           shift and go to state 19

state 16

    (3) Function -> FunctionReturnType ID ( ) { Declarations . Statements ReturnStatement }
    (16) Statements -> . Statement Statements
    (17) Statements -> . empty
    (18) Statement -> . Assignment
    (19) Statement -> . IfStatement
    (20) Statement -> . WhileStatement
    (21) Statement -> . ForStatement
    (22) Statement -> . ;
    (23) Statement -> . Block
    (6) empty -> .
    (28) Assignment -> . ID = Expression ;
    (25) IfStatement -> . IF ( Expression ) Statement ELSE Statement
    (26) WhileStatement -> . WHILE ( Expression ) Statement
    (27) ForStatement -> . FOR ( Assignment Expression ; Assignment ) Statement
    (24) Block -> . { Statements }

    ;               shift and go to state 29
    RETURN          reduce using rule 6 (empty -> .)
    ID              shift and go to state 20
    IF              shift and go to state 31
    WHILE           shift and go to state 32
    FOR             shift and go to state 33
    {               shift and go to state 21

    Statements                     shift and go to state 22
    Statement                      shift and go to state 23
    empty                          shift and go to state 24
    Assignment                     shift and go to state 25
    IfStatement                    shift and go to state 26
    WhileStatement                 shift and go to state 27
    ForStatement                   shift and go to state 28
    Block                          shift and go to state 30

state 17

    (7) Declarations -> Declaration . Declarations
    (7) Declarations -> . Declaration Declarations
    (8) Declarations -> . empty
    (9) Declaration -> . Type ID ;
    (6) empty -> .
    (10) Type -> . INT
    (11) Type -> . BOOL
    (12) Type -> . FLOAT
    (13) Type -> . CHAR

    ;               reduce using rule 6 (empty -> .)
    ID              reduce using rule 6 (empty -> .)
    IF              reduce using rule 6 (empty -> .)
    WHILE           reduce using rule 6 (empty -> .)
    FOR             reduce using rule 6 (empty -> .)
    {               reduce using rule 6 (empty -> .)
    RETURN          reduce using rule 6 (empty -> .)
    INT             shift and go to state 7
    BOOL            shift and go to state 8
    FLOAT           shift and go to state 9
    CHAR            shift and go to state 10

    Declaration                    shift and go to state 17
    Declarations                   shift and go to state 34
    empty                          shift and go to state 18
    Type                           shift and go to state 19

state 18

    (8) Declarations -> empty .

    ;               reduce using rule 8 (Declarations -> empty .)
    ID              reduce using rule 8 (Declarations -> empty .)
    IF              reduce using rule 8 (Declarations -> empty .)
    WHILE           reduce using rule 8 (Declarations -> empty .)
    FOR             reduce using rule 8 (Declarations -> empty .)
    {               reduce using rule 8 (Declarations -> empty .)
    RETURN          reduce using rule 8 (Declarations -> empty .)


state 19

    (9) Declaration -> Type . ID ;

    ID              shift and go to state 35


state 20

    (28) Assignment -> ID . = Expression ;

    =               shift and go to state 36


state 21

    (24) Block -> { . Statements }
    (16) Statements -> . Statement Statements
    (17) Statements -> . empty
    (18) Statement -> . Assignment
    (19) Statement -> . IfStatement
    (20) Statement -> . WhileStatement
    (21) Statement -> . ForStatement
    (22) Statement -> . ;
    (23) Statement -> . Block
    (6) empty -> .
    (28) Assignment -> . ID = Expression ;
    (25) IfStatement -> . IF ( Expression ) Statement ELSE Statement
    (26) WhileStatement -> . WHILE ( Expression ) Statement
    (27) ForStatement -> . FOR ( Assignment Expression ; Assignment ) Statement
    (24) Block -> . { Statements }

    ;               shift and go to state 29
    }               reduce using rule 6 (empty -> .)
    ID              shift and go to state 20
    IF              shift and go to state 31
    WHILE           shift and go to state 32
    FOR             shift and go to state 33
    {               shift and go to state 21

    Statements                     shift and go to state 37
    Statement                      shift and go to state 23
    empty                          shift and go to state 24
    Assignment                     shift and go to state 25
    IfStatement                    shift and go to state 26
    WhileStatement                 shift and go to state 27
    ForStatement                   shift and go to state 28
    Block                          shift and go to state 30

state 22

    (3) Function -> FunctionReturnType ID ( ) { Declarations Statements . ReturnStatement }
    (4) ReturnStatement -> . RETURN Expression ;
    (5) ReturnStatement -> . RETURN ;

    RETURN          shift and go to state 39

    ReturnStatement                shift and go to state 38

state 23

    (16) Statements -> Statement . Statements
    (16) Statements -> . Statement Statements
    (17) Statements -> . empty
    (18) Statement -> . Assignment
    (19) Statement -> . IfStatement
    (20) Statement -> . WhileStatement
    (21) Statement -> . ForStatement
    (22) Statement -> . ;
    (23) Statement -> . Block
    (6) empty -> .
    (28) Assignment -> . ID = Expression ;
    (25) IfStatement -> . IF ( Expression ) Statement ELSE Statement
    (26) WhileStatement -> . WHILE ( Expression ) Statement
    (27) ForStatement -> . FOR ( Assignment Expression ; Assignment ) Statement
    (24) Block -> . { Statements }

    ;               shift and go to state 29
    RETURN          reduce using rule 6 (empty -> .)
    }               reduce using rule 6 (empty -> .)
    ID              shift and go to state 20
    IF              shift and go to state 31
    WHILE           shift and go to state 32
    FOR             shift and go to state 33
    {               shift and go to state 21

    Statement                      shift and go to state 23
    Statements                     shift and go to state 40
    empty                          shift and go to state 24
    Assignment                     shift and go to state 25
    IfStatement                    shift and go to state 26
    WhileStatement                 shift and go to state 27
    ForStatement                   shift and go to state 28
    Block                          shift and go to state 30

state 24

    (17) Statements -> empty .

    RETURN          reduce using rule 17 (Statements -> empty .)
    }               reduce using rule 17 (Statements -> empty .)


state 25

    (18) Statement -> Assignment .

    ;               reduce using rule 18 (Statement -> Assignment .)
    ID              reduce using rule 18 (Statement -> Assignment .)
    IF              reduce using rule 18 (Statement -> Assignment .)
    WHILE           reduce using rule 18 (Statement -> Assignment .)
    FOR             reduce using rule 18 (Statement -> Assignment .)
    {               reduce using rule 18 (Statement -> Assignment .)
    RETURN          reduce using rule 18 (Statement -> Assignment .)
    }               reduce using rule 18 (Statement -> Assignment .)
    ELSE            reduce using rule 18 (Statement -> Assignment .)


state 26

    (19) Statement -> IfStatement .

    ;               reduce using rule 19 (Statement -> IfStatement .)
    ID              reduce using rule 19 (Statement -> IfStatement .)
    IF              reduce using rule 19 (Statement -> IfStatement .)
    WHILE           reduce using rule 19 (Statement -> IfStatement .)
    FOR             reduce using rule 19 (Statement -> IfStatement .)
    {               reduce using rule 19 (Statement -> IfStatement .)
    RETURN          reduce using rule 19 (Statement -> IfStatement .)
    }               reduce using rule 19 (Statement -> IfStatement .)
    ELSE            reduce using rule 19 (Statement -> IfStatement .)


state 27

    (20) Statement -> WhileStatement .

    ;               reduce using rule 20 (Statement -> WhileStatement .)
    ID              reduce using rule 20 (Statement -> WhileStatement .)
    IF              reduce using rule 20 (Statement -> WhileStatement .)
    WHILE           reduce using rule 20 (Statement -> WhileStatement .)
    FOR             reduce using rule 20 (Statement -> WhileStatement .)
    {               reduce using rule 20 (Statement -> WhileStatement .)
    RETURN          reduce using rule 20 (Statement -> WhileStatement .)
    }               reduce using rule 20 (Statement -> WhileStatement .)
    ELSE            reduce using rule 20 (Statement -> WhileStatement .)


state 28

    (21) Statement -> ForStatement .

    ;               reduce using rule 21 (Statement -> ForStatement .)
    ID              reduce using rule 21 (Statement -> ForStatement .)
    IF              reduce using rule 21 (Statement -> ForStatement .)
    WHILE           reduce using rule 21 (Statement -> ForStatement .)
    FOR             reduce using rule 21 (Statement -> ForStatement .)
    {               reduce using rule 21 (Statement -> ForStatement .)
    RETURN          reduce using rule 21 (Statement -> ForStatement .)
    }               reduce using rule 21 (Statement -> ForStatement .)
    ELSE            reduce using rule 21 (Statement -> ForStatement .)


state 29

    (22) Statement -> ; .

    ;               reduce using rule 22 (Statement -> ; .)
    ID              reduce using rule 22 (Statement -> ; .)
    IF              reduce using rule 22 (Statement -> ; .)
    WHILE           reduce using rule 22 (Statement -> ; .)
    FOR             reduce using rule 22 (Statement -> ; .)
    {               reduce using rule 22 (Statement -> ; .)
    RETURN          reduce using rule 22 (Statement -> ; .)
    }               reduce using rule 22 (Statement -> ; .)
    ELSE            reduce using rule 22 (Statement -> ; .)


state 30

    (23) Statement -> Block .

    ;               reduce using rule 23 (Statement -> Block .)
    ID              reduce using rule 23 (Statement -> Block .)
    IF              reduce using rule 23 (Statement -> Block .)
    WHILE           reduce using rule 23 (Statement -> Block .)
    FOR             reduce using rule 23 (Statement -> Block .)
    {               reduce using rule 23 (Statement -> Block .)
    RETURN          reduce using rule 23 (Statement -> Block .)
    }               reduce using rule 23 (Statement -> Block .)
    ELSE            reduce using rule 23 (Statement -> Block .)


state 31

    (25) IfStatement -> IF . ( Expression ) Statement ELSE Statement

    (               shift and go to state 41


state 32

    (26) WhileStatement -> WHILE . ( Expression ) Statement

    (               shift and go to state 42


state 33

    (27) ForStatement -> FOR . ( Assignment Expression ; Assignment ) Statement

    (               shift and go to state 43


state 34

    (7) Declarations -> Declaration Declarations .

    ;               reduce using rule 7 (Declarations -> Declaration Declarations .)
    ID              reduce using rule 7 (Declarations -> Declaration Declarations .)
    IF              reduce using rule 7 (Declarations -> Declaration Declarations .)
    WHILE           reduce using rule 7 (Declarations -> Declaration Declarations .)
    FOR             reduce using rule 7 (Declarations -> Declaration Declarations .)
    {               reduce using rule 7 (Declarations -> Declaration Declarations .)
    RETURN          reduce using rule 7 (Declarations -> Declaration Declarations .)


state 35

    (9) Declaration -> Type ID . ;

    ;               shift and go to state 44


state 36

    (28) Assignment -> ID = . Expression ;
    (29) Expression -> . Conjunction
    (30) Expression -> . Expression OR Conjunction
    (31) Conjunction -> . Equality
    (32) Conjunction -> . Conjunction AND Equality
    (33) Equality -> . Relation
    (34) Equality -> . Relation EquOp Relation
    (37) Relation -> . Addition
    (38) Relation -> . Addition RelOp Addition
    (43) Addition -> . Term
    (44) Addition -> . Addition AddOp Term
    (47) Term -> . Factor
    (48) Term -> . Term MulOp Primary
    (52) Factor -> . Primary
    (53) Factor -> . UnaryOp Primary
    (56) Primary -> . INTLIT
    (57) Primary -> . ID
    (58) Primary -> . ID ( )
    (54) UnaryOp -> . -
    (55) UnaryOp -> . !

    INTLIT          shift and go to state 55
    ID              shift and go to state 45
    -               shift and go to state 56
    !               shift and go to state 57

    Expression                     shift and go to state 46
    Conjunction                    shift and go to state 47
    Equality                       shift and go to state 48
    Relation                       shift and go to state 49
    Addition                       shift and go to state 50
    Term                           shift and go to state 51
    Factor                         shift and go to state 52
    Primary                        shift and go to state 53
    UnaryOp                        shift and go to state 54

state 37

    (24) Block -> { Statements . }

    }               shift and go to state 58


state 38

    (3) Function -> FunctionReturnType ID ( ) { Declarations Statements ReturnStatement . }

    }               shift and go to state 59


state 39

    (4) ReturnStatement -> RETURN . Expression ;
    (5) ReturnStatement -> RETURN . ;
    (29) Expression -> . Conjunction
    (30) Expression -> . Expression OR Conjunction
    (31) Conjunction -> . Equality
    (32) Conjunction -> . Conjunction AND Equality
    (33) Equality -> . Relation
    (34) Equality -> . Relation EquOp Relation
    (37) Relation -> . Addition
    (38) Relation -> . Addition RelOp Addition
    (43) Addition -> . Term
    (44) Addition -> . Addition AddOp Term
    (47) Term -> . Factor
    (48) Term -> . Term MulOp Primary
    (52) Factor -> . Primary
    (53) Factor -> . UnaryOp Primary
    (56) Primary -> . INTLIT
    (57) Primary -> . ID
    (58) Primary -> . ID ( )
    (54) UnaryOp -> . -
    (55) UnaryOp -> . !

    ;               shift and go to state 61
    INTLIT          shift and go to state 55
    ID              shift and go to state 45
    -               shift and go to state 56
    !               shift and go to state 57

    Expression                     shift and go to state 60
    Conjunction                    shift and go to state 47
    Equality                       shift and go to state 48
    Relation                       shift and go to state 49
    Addition                       shift and go to state 50
    Term                           shift and go to state 51
    Factor                         shift and go to state 52
    Primary                        shift and go to state 53
    UnaryOp                        shift and go to state 54

state 40

    (16) Statements -> Statement Statements .

    RETURN          reduce using rule 16 (Statements -> Statement Statements .)
    }               reduce using rule 16 (Statements -> Statement Statements .)


state 41

    (25) IfStatement -> IF ( . Expression ) Statement ELSE Statement
    (29) Expression -> . Conjunction
    (30) Expression -> . Expression OR Conjunction
    (31) Conjunction -> . Equality
    (32) Conjunction -> . Conjunction AND Equality
    (33) Equality -> . Relation
    (34) Equality -> . Relation EquOp Relation
    (37) Relation -> . Addition
    (38) Relation -> . Addition RelOp Addition
    (43) Addition -> . Term
    (44) Addition -> . Addition AddOp Term
    (47) Term -> . Factor
    (48) Term -> . Term MulOp Primary
    (52) Factor -> . Primary
    (53) Factor -> . UnaryOp Primary
    (56) Primary -> . INTLIT
    (57) Primary -> . ID
    (58) Primary -> . ID ( )
    (54) UnaryOp -> . -
    (55) UnaryOp -> . !

    INTLIT          shift and go to state 55
    ID              shift and go to state 45
    -               shift and go to state 56
    !               shift and go to state 57

    Expression                     shift and go to state 62
    Conjunction                    shift and go to state 47
    Equality                       shift and go to state 48
    Relation                       shift and go to state 49
    Addition                       shift and go to state 50
    Term                           shift and go to state 51
    Factor                         shift and go to state 52
    Primary                        shift and go to state 53
    UnaryOp                        shift and go to state 54

state 42

    (26) WhileStatement -> WHILE ( . Expression ) Statement
    (29) Expression -> . Conjunction
    (30) Expression -> . Expression OR Conjunction
    (31) Conjunction -> . Equality
    (32) Conjunction -> . Conjunction AND Equality
    (33) Equality -> . Relation
    (34) Equality -> . Relation EquOp Relation
    (37) Relation -> . Addition
    (38) Relation -> . Addition RelOp Addition
    (43) Addition -> . Term
    (44) Addition -> . Addition AddOp Term
    (47) Term -> . Factor
    (48) Term -> . Term MulOp Primary
    (52) Factor -> . Primary
    (53) Factor -> . UnaryOp Primary
    (56) Primary -> . INTLIT
    (57) Primary -> . ID
    (58) Primary -> . ID ( )
    (54) UnaryOp -> . -
    (55) UnaryOp -> . !

    INTLIT          shift and go to state 55
    ID              shift and go to state 45
    -               shift and go to state 56
    !               shift and go to state 57

    Expression                     shift and go to state 63
    Conjunction                    shift and go to state 47
    Equality                       shift and go to state 48
    Relation                       shift and go to state 49
    Addition                       shift and go to state 50
    Term                           shift and go to state 51
    Factor                         shift and go to state 52
    Primary                        shift and go to state 53
    UnaryOp                        shift and go to state 54

state 43

    (27) ForStatement -> FOR ( . Assignment Expression ; Assignment ) Statement
    (28) Assignment -> . ID = Expression ;

    ID              shift and go to state 20

    Assignment                     shift and go to state 64

state 44

    (9) Declaration -> Type ID ; .

    INT             reduce using rule 9 (Declaration -> Type ID ; .)
    BOOL            reduce using rule 9 (Declaration -> Type ID ; .)
    FLOAT           reduce using rule 9 (Declaration -> Type ID ; .)
    CHAR            reduce using rule 9 (Declaration -> Type ID ; .)
    ;               reduce using rule 9 (Declaration -> Type ID ; .)
    ID              reduce using rule 9 (Declaration -> Type ID ; .)
    IF              reduce using rule 9 (Declaration -> Type ID ; .)
    WHILE           reduce using rule 9 (Declaration -> Type ID ; .)
    FOR             reduce using rule 9 (Declaration -> Type ID ; .)
    {               reduce using rule 9 (Declaration -> Type ID ; .)
    RETURN          reduce using rule 9 (Declaration -> Type ID ; .)


state 45

    (57) Primary -> ID .
    (58) Primary -> ID . ( )

    *               reduce using rule 57 (Primary -> ID .)
    /               reduce using rule 57 (Primary -> ID .)
    %               reduce using rule 57 (Primary -> ID .)
    <               reduce using rule 57 (Primary -> ID .)
    LTE             reduce using rule 57 (Primary -> ID .)
    >               reduce using rule 57 (Primary -> ID .)
    GTE             reduce using rule 57 (Primary -> ID .)
    +               reduce using rule 57 (Primary -> ID .)
    -               reduce using rule 57 (Primary -> ID .)
    EQ              reduce using rule 57 (Primary -> ID .)
    NEQ             reduce using rule 57 (Primary -> ID .)
    AND             reduce using rule 57 (Primary -> ID .)
    ;               reduce using rule 57 (Primary -> ID .)
    OR              reduce using rule 57 (Primary -> ID .)
    )               reduce using rule 57 (Primary -> ID .)
    (               shift and go to state 65


state 46

    (28) Assignment -> ID = Expression . ;
    (30) Expression -> Expression . OR Conjunction

    ;               shift and go to state 66
    OR              shift and go to state 67


state 47

    (29) Expression -> Conjunction .
    (32) Conjunction -> Conjunction . AND Equality

    ;               reduce using rule 29 (Expression -> Conjunction .)
    OR              reduce using rule 29 (Expression -> Conjunction .)
    )               reduce using rule 29 (Expression -> Conjunction .)
    AND             shift and go to state 68


state 48

    (31) Conjunction -> Equality .

    AND             reduce using rule 31 (Conjunction -> Equality .)
    ;               reduce using rule 31 (Conjunction -> Equality .)
    OR              reduce using rule 31 (Conjunction -> Equality .)
    )               reduce using rule 31 (Conjunction -> Equality .)


state 49

    (33) Equality -> Relation .
    (34) Equality -> Relation . EquOp Relation
    (35) EquOp -> . EQ
    (36) EquOp -> . NEQ

    AND             reduce using rule 33 (Equality -> Relation .)
    ;               reduce using rule 33 (Equality -> Relation .)
    OR              reduce using rule 33 (Equality -> Relation .)
    )               reduce using rule 33 (Equality -> Relation .)
    EQ              shift and go to state 70
    NEQ             shift and go to state 71

    EquOp                          shift and go to state 69

state 50

    (37) Relation -> Addition .
    (38) Relation -> Addition . RelOp Addition
    (44) Addition -> Addition . AddOp Term
    (39) RelOp -> . <
    (40) RelOp -> . LTE
    (41) RelOp -> . >
    (42) RelOp -> . GTE
    (45) AddOp -> . +
    (46) AddOp -> . -

    EQ              reduce using rule 37 (Relation -> Addition .)
    NEQ             reduce using rule 37 (Relation -> Addition .)
    AND             reduce using rule 37 (Relation -> Addition .)
    ;               reduce using rule 37 (Relation -> Addition .)
    OR              reduce using rule 37 (Relation -> Addition .)
    )               reduce using rule 37 (Relation -> Addition .)
    <               shift and go to state 74
    LTE             shift and go to state 75
    >               shift and go to state 76
    GTE             shift and go to state 77
    +               shift and go to state 78
    -               shift and go to state 79

    RelOp                          shift and go to state 72
    AddOp                          shift and go to state 73

state 51

    (43) Addition -> Term .
    (48) Term -> Term . MulOp Primary
    (49) MulOp -> . *
    (50) MulOp -> . /
    (51) MulOp -> . %

    <               reduce using rule 43 (Addition -> Term .)
    LTE             reduce using rule 43 (Addition -> Term .)
    >               reduce using rule 43 (Addition -> Term .)
    GTE             reduce using rule 43 (Addition -> Term .)
    +               reduce using rule 43 (Addition -> Term .)
    -               reduce using rule 43 (Addition -> Term .)
    EQ              reduce using rule 43 (Addition -> Term .)
    NEQ             reduce using rule 43 (Addition -> Term .)
    AND             reduce using rule 43 (Addition -> Term .)
    ;               reduce using rule 43 (Addition -> Term .)
    OR              reduce using rule 43 (Addition -> Term .)
    )               reduce using rule 43 (Addition -> Term .)
    *               shift and go to state 81
    /               shift and go to state 82
    %               shift and go to state 83

    MulOp                          shift and go to state 80

state 52

    (47) Term -> Factor .

    *               reduce using rule 47 (Term -> Factor .)
    /               reduce using rule 47 (Term -> Factor .)
    %               reduce using rule 47 (Term -> Factor .)
    <               reduce using rule 47 (Term -> Factor .)
    LTE             reduce using rule 47 (Term -> Factor .)
    >               reduce using rule 47 (Term -> Factor .)
    GTE             reduce using rule 47 (Term -> Factor .)
    +               reduce using rule 47 (Term -> Factor .)
    -               reduce using rule 47 (Term -> Factor .)
    EQ              reduce using rule 47 (Term -> Factor .)
    NEQ             reduce using rule 47 (Term -> Factor .)
    AND             reduce using rule 47 (Term -> Factor .)
    ;               reduce using rule 47 (Term -> Factor .)
    OR              reduce using rule 47 (Term -> Factor .)
    )               reduce using rule 47 (Term -> Factor .)


state 53

    (52) Factor -> Primary .

    *               reduce using rule 52 (Factor -> Primary .)
    /               reduce using rule 52 (Factor -> Primary .)
    %               reduce using rule 52 (Factor -> Primary .)
    <               reduce using rule 52 (Factor -> Primary .)
    LTE             reduce using rule 52 (Factor -> Primary .)
    >               reduce using rule 52 (Factor -> Primary .)
    GTE             reduce using rule 52 (Factor -> Primary .)
    +               reduce using rule 52 (Factor -> Primary .)
    -               reduce using rule 52 (Factor -> Primary .)
    EQ              reduce using rule 52 (Factor -> Primary .)
    NEQ             reduce using rule 52 (Factor -> Primary .)
    AND             reduce using rule 52 (Factor -> Primary .)
    ;               reduce using rule 52 (Factor -> Primary .)
    OR              reduce using rule 52 (Factor -> Primary .)
    )               reduce using rule 52 (Factor -> Primary .)


state 54

    (53) Factor -> UnaryOp . Primary
    (56) Primary -> . INTLIT
    (57) Primary -> . ID
    (58) Primary -> . ID ( )

    INTLIT          shift and go to state 55
    ID              shift and go to state 45

    Primary                        shift and go to state 84

state 55

    (56) Primary -> INTLIT .

    *               reduce using rule 56 (Primary -> INTLIT .)
    /               reduce using rule 56 (Primary -> INTLIT .)
    %               reduce using rule 56 (Primary -> INTLIT .)
    <               reduce using rule 56 (Primary -> INTLIT .)
    LTE             reduce using rule 56 (Primary -> INTLIT .)
    >               reduce using rule 56 (Primary -> INTLIT .)
    GTE             reduce using rule 56 (Primary -> INTLIT .)
    +               reduce using rule 56 (Primary -> INTLIT .)
    -               reduce using rule 56 (Primary -> INTLIT .)
    EQ              reduce using rule 56 (Primary -> INTLIT .)
    NEQ             reduce using rule 56 (Primary -> INTLIT .)
    AND             reduce using rule 56 (Primary -> INTLIT .)
    ;               reduce using rule 56 (Primary -> INTLIT .)
    OR              reduce using rule 56 (Primary -> INTLIT .)
    )               reduce using rule 56 (Primary -> INTLIT .)


state 56

    (54) UnaryOp -> - .

    INTLIT          reduce using rule 54 (UnaryOp -> - .)
    ID              reduce using rule 54 (UnaryOp -> - .)


state 57

    (55) UnaryOp -> ! .

    INTLIT          reduce using rule 55 (UnaryOp -> ! .)
    ID              reduce using rule 55 (UnaryOp -> ! .)


state 58

    (24) Block -> { Statements } .

    ;               reduce using rule 24 (Block -> { Statements } .)
    ID              reduce using rule 24 (Block -> { Statements } .)
    IF              reduce using rule 24 (Block -> { Statements } .)
    WHILE           reduce using rule 24 (Block -> { Statements } .)
    FOR             reduce using rule 24 (Block -> { Statements } .)
    {               reduce using rule 24 (Block -> { Statements } .)
    RETURN          reduce using rule 24 (Block -> { Statements } .)
    }               reduce using rule 24 (Block -> { Statements } .)
    ELSE            reduce using rule 24 (Block -> { Statements } .)


state 59

    (3) Function -> FunctionReturnType ID ( ) { Declarations Statements ReturnStatement } .

    VOID            reduce using rule 3 (Function -> FunctionReturnType ID ( ) { Declarations Statements ReturnStatement } .)
    INT             reduce using rule 3 (Function -> FunctionReturnType ID ( ) { Declarations Statements ReturnStatement } .)
    BOOL            reduce using rule 3 (Function -> FunctionReturnType ID ( ) { Declarations Statements ReturnStatement } .)
    FLOAT           reduce using rule 3 (Function -> FunctionReturnType ID ( ) { Declarations Statements ReturnStatement } .)
    CHAR            reduce using rule 3 (Function -> FunctionReturnType ID ( ) { Declarations Statements ReturnStatement } .)
    $end            reduce using rule 3 (Function -> FunctionReturnType ID ( ) { Declarations Statements ReturnStatement } .)


state 60

    (4) ReturnStatement -> RETURN Expression . ;
    (30) Expression -> Expression . OR Conjunction

    ;               shift and go to state 85
    OR              shift and go to state 67


state 61

    (5) ReturnStatement -> RETURN ; .

    }               reduce using rule 5 (ReturnStatement -> RETURN ; .)


state 62

    (25) IfStatement -> IF ( Expression . ) Statement ELSE Statement
    (30) Expression -> Expression . OR Conjunction

    )               shift and go to state 86
    OR              shift and go to state 67


state 63

    (26) WhileStatement -> WHILE ( Expression . ) Statement
    (30) Expression -> Expression . OR Conjunction

    )               shift and go to state 87
    OR              shift and go to state 67


state 64

    (27) ForStatement -> FOR ( Assignment . Expression ; Assignment ) Statement
    (29) Expression -> . Conjunction
    (30) Expression -> . Expression OR Conjunction
    (31) Conjunction -> . Equality
    (32) Conjunction -> . Conjunction AND Equality
    (33) Equality -> . Relation
    (34) Equality -> . Relation EquOp Relation
    (37) Relation -> . Addition
    (38) Relation -> . Addition RelOp Addition
    (43) Addition -> . Term
    (44) Addition -> . Addition AddOp Term
    (47) Term -> . Factor
    (48) Term -> . Term MulOp Primary
    (52) Factor -> . Primary
    (53) Factor -> . UnaryOp Primary
    (56) Primary -> . INTLIT
    (57) Primary -> . ID
    (58) Primary -> . ID ( )
    (54) UnaryOp -> . -
    (55) UnaryOp -> . !

    INTLIT          shift and go to state 55
    ID              shift and go to state 45
    -               shift and go to state 56
    !               shift and go to state 57

    Expression                     shift and go to state 88
    Conjunction                    shift and go to state 47
    Equality                       shift and go to state 48
    Relation                       shift and go to state 49
    Addition                       shift and go to state 50
    Term                           shift and go to state 51
    Factor                         shift and go to state 52
    Primary                        shift and go to state 53
    UnaryOp                        shift and go to state 54

state 65

    (58) Primary -> ID ( . )

    )               shift and go to state 89


state 66

    (28) Assignment -> ID = Expression ; .

    ;               reduce using rule 28 (Assignment -> ID = Expression ; .)
    ID              reduce using rule 28 (Assignment -> ID = Expression ; .)
    IF              reduce using rule 28 (Assignment -> ID = Expression ; .)
    WHILE           reduce using rule 28 (Assignment -> ID = Expression ; .)
    FOR             reduce using rule 28 (Assignment -> ID = Expression ; .)
    {               reduce using rule 28 (Assignment -> ID = Expression ; .)
    RETURN          reduce using rule 28 (Assignment -> ID = Expression ; .)
    }               reduce using rule 28 (Assignment -> ID = Expression ; .)
    INTLIT          reduce using rule 28 (Assignment -> ID = Expression ; .)
    -               reduce using rule 28 (Assignment -> ID = Expression ; .)
    !               reduce using rule 28 (Assignment -> ID = Expression ; .)
    ELSE            reduce using rule 28 (Assignment -> ID = Expression ; .)
    )               reduce using rule 28 (Assignment -> ID = Expression ; .)


state 67

    (30) Expression -> Expression OR . Conjunction
    (31) Conjunction -> . Equality
    (32) Conjunction -> . Conjunction AND Equality
    (33) Equality -> . Relation
    (34) Equality -> . Relation EquOp Relation
    (37) Relation -> . Addition
    (38) Relation -> . Addition RelOp Addition
    (43) Addition -> . Term
    (44) Addition -> . Addition AddOp Term
    (47) Term -> . Factor
    (48) Term -> . Term MulOp Primary
    (52) Factor -> . Primary
    (53) Factor -> . UnaryOp Primary
    (56) Primary -> . INTLIT
    (57) Primary -> . ID
    (58) Primary -> . ID ( )
    (54) UnaryOp -> . -
    (55) UnaryOp -> . !

    INTLIT          shift and go to state 55
    ID              shift and go to state 45
    -               shift and go to state 56
    !               shift and go to state 57

    Conjunction                    shift and go to state 90
    Equality                       shift and go to state 48
    Relation                       shift and go to state 49
    Addition                       shift and go to state 50
    Term                           shift and go to state 51
    Factor                         shift and go to state 52
    Primary                        shift and go to state 53
    UnaryOp                        shift and go to state 54

state 68

    (32) Conjunction -> Conjunction AND . Equality
    (33) Equality -> . Relation
    (34) Equality -> . Relation EquOp Relation
    (37) Relation -> . Addition
    (38) Relation -> . Addition RelOp Addition
    (43) Addition -> . Term
    (44) Addition -> . Addition AddOp Term
    (47) Term -> . Factor
    (48) Term -> . Term MulOp Primary
    (52) Factor -> . Primary
    (53) Factor -> . UnaryOp Primary
    (56) Primary -> . INTLIT
    (57) Primary -> . ID
    (58) Primary -> . ID ( )
    (54) UnaryOp -> . -
    (55) UnaryOp -> . !

    INTLIT          shift and go to state 55
    ID              shift and go to state 45
    -               shift and go to state 56
    !               shift and go to state 57

    Equality                       shift and go to state 91
    Relation                       shift and go to state 49
    Addition                       shift and go to state 50
    Term                           shift and go to state 51
    Factor                         shift and go to state 52
    Primary                        shift and go to state 53
    UnaryOp                        shift and go to state 54

state 69

    (34) Equality -> Relation EquOp . Relation
    (37) Relation -> . Addition
    (38) Relation -> . Addition RelOp Addition
    (43) Addition -> . Term
    (44) Addition -> . Addition AddOp Term
    (47) Term -> . Factor
    (48) Term -> . Term MulOp Primary
    (52) Factor -> . Primary
    (53) Factor -> . UnaryOp Primary
    (56) Primary -> . INTLIT
    (57) Primary -> . ID
    (58) Primary -> . ID ( )
    (54) UnaryOp -> . -
    (55) UnaryOp -> . !

    INTLIT          shift and go to state 55
    ID              shift and go to state 45
    -               shift and go to state 56
    !               shift and go to state 57

    Relation                       shift and go to state 92
    Addition                       shift and go to state 50
    Term                           shift and go to state 51
    Factor                         shift and go to state 52
    Primary                        shift and go to state 53
    UnaryOp                        shift and go to state 54

state 70

    (35) EquOp -> EQ .

    INTLIT          reduce using rule 35 (EquOp -> EQ .)
    ID              reduce using rule 35 (EquOp -> EQ .)
    -               reduce using rule 35 (EquOp -> EQ .)
    !               reduce using rule 35 (EquOp -> EQ .)


state 71

    (36) EquOp -> NEQ .

    INTLIT          reduce using rule 36 (EquOp -> NEQ .)
    ID              reduce using rule 36 (EquOp -> NEQ .)
    -               reduce using rule 36 (EquOp -> NEQ .)
    !               reduce using rule 36 (EquOp -> NEQ .)


state 72

    (38) Relation -> Addition RelOp . Addition
    (43) Addition -> . Term
    (44) Addition -> . Addition AddOp Term
    (47) Term -> . Factor
    (48) Term -> . Term MulOp Primary
    (52) Factor -> . Primary
    (53) Factor -> . UnaryOp Primary
    (56) Primary -> . INTLIT
    (57) Primary -> . ID
    (58) Primary -> . ID ( )
    (54) UnaryOp -> . -
    (55) UnaryOp -> . !

    INTLIT          shift and go to state 55
    ID              shift and go to state 45
    -               shift and go to state 56
    !               shift and go to state 57

    Addition                       shift and go to state 93
    Term                           shift and go to state 51
    Factor                         shift and go to state 52
    Primary                        shift and go to state 53
    UnaryOp                        shift and go to state 54

state 73

    (44) Addition -> Addition AddOp . Term
    (47) Term -> . Factor
    (48) Term -> . Term MulOp Primary
    (52) Factor -> . Primary
    (53) Factor -> . UnaryOp Primary
    (56) Primary -> . INTLIT
    (57) Primary -> . ID
    (58) Primary -> . ID ( )
    (54) UnaryOp -> . -
    (55) UnaryOp -> . !

    INTLIT          shift and go to state 55
    ID              shift and go to state 45
    -               shift and go to state 56
    !               shift and go to state 57

    Term                           shift and go to state 94
    Factor                         shift and go to state 52
    Primary                        shift and go to state 53
    UnaryOp                        shift and go to state 54

state 74

    (39) RelOp -> < .

    INTLIT          reduce using rule 39 (RelOp -> < .)
    ID              reduce using rule 39 (RelOp -> < .)
    -               reduce using rule 39 (RelOp -> < .)
    !               reduce using rule 39 (RelOp -> < .)


state 75

    (40) RelOp -> LTE .

    INTLIT          reduce using rule 40 (RelOp -> LTE .)
    ID              reduce using rule 40 (RelOp -> LTE .)
    -               reduce using rule 40 (RelOp -> LTE .)
    !               reduce using rule 40 (RelOp -> LTE .)


state 76

    (41) RelOp -> > .

    INTLIT          reduce using rule 41 (RelOp -> > .)
    ID              reduce using rule 41 (RelOp -> > .)
    -               reduce using rule 41 (RelOp -> > .)
    !               reduce using rule 41 (RelOp -> > .)


state 77

    (42) RelOp -> GTE .

    INTLIT          reduce using rule 42 (RelOp -> GTE .)
    ID              reduce using rule 42 (RelOp -> GTE .)
    -               reduce using rule 42 (RelOp -> GTE .)
    !               reduce using rule 42 (RelOp -> GTE .)


state 78

    (45) AddOp -> + .

    INTLIT          reduce using rule 45 (AddOp -> + .)
    ID              reduce using rule 45 (AddOp -> + .)
    -               reduce using rule 45 (AddOp -> + .)
    !               reduce using rule 45 (AddOp -> + .)


state 79

    (46) AddOp -> - .

    INTLIT          reduce using rule 46 (AddOp -> - .)
    ID              reduce using rule 46 (AddOp -> - .)
    -               reduce using rule 46 (AddOp -> - .)
    !               reduce using rule 46 (AddOp -> - .)


state 80

    (48) Term -> Term MulOp . Primary
    (56) Primary -> . INTLIT
    (57) Primary -> . ID
    (58) Primary -> . ID ( )

    INTLIT          shift and go to state 55
    ID              shift and go to state 45

    Primary                        shift and go to state 95

state 81

    (49) MulOp -> * .

    INTLIT          reduce using rule 49 (MulOp -> * .)
    ID              reduce using rule 49 (MulOp -> * .)


state 82

    (50) MulOp -> / .

    INTLIT          reduce using rule 50 (MulOp -> / .)
    ID              reduce using rule 50 (MulOp -> / .)


state 83

    (51) MulOp -> % .

    INTLIT          reduce using rule 51 (MulOp -> % .)
    ID              reduce using rule 51 (MulOp -> % .)


state 84

    (53) Factor -> UnaryOp Primary .

    *               reduce using rule 53 (Factor -> UnaryOp Primary .)
    /               reduce using rule 53 (Factor -> UnaryOp Primary .)
    %               reduce using rule 53 (Factor -> UnaryOp Primary .)
    <               reduce using rule 53 (Factor -> UnaryOp Primary .)
    LTE             reduce using rule 53 (Factor -> UnaryOp Primary .)
    >               reduce using rule 53 (Factor -> UnaryOp Primary .)
    GTE             reduce using rule 53 (Factor -> UnaryOp Primary .)
    +               reduce using rule 53 (Factor -> UnaryOp Primary .)
    -               reduce using rule 53 (Factor -> UnaryOp Primary .)
    EQ              reduce using rule 53 (Factor -> UnaryOp Primary .)
    NEQ             reduce using rule 53 (Factor -> UnaryOp Primary .)
    AND             reduce using rule 53 (Factor -> UnaryOp Primary .)
    ;               reduce using rule 53 (Factor -> UnaryOp Primary .)
    OR              reduce using rule 53 (Factor -> UnaryOp Primary .)
    )               reduce using rule 53 (Factor -> UnaryOp Primary .)


state 85

    (4) ReturnStatement -> RETURN Expression ; .

    }               reduce using rule 4 (ReturnStatement -> RETURN Expression ; .)


state 86

    (25) IfStatement -> IF ( Expression ) . Statement ELSE Statement
    (18) Statement -> . Assignment
    (19) Statement -> . IfStatement
    (20) Statement -> . WhileStatement
    (21) Statement -> . ForStatement
    (22) Statement -> . ;
    (23) Statement -> . Block
    (28) Assignment -> . ID = Expression ;
    (25) IfStatement -> . IF ( Expression ) Statement ELSE Statement
    (26) WhileStatement -> . WHILE ( Expression ) Statement
    (27) ForStatement -> . FOR ( Assignment Expression ; Assignment ) Statement
    (24) Block -> . { Statements }

    ;               shift and go to state 29
    ID              shift and go to state 20
    IF              shift and go to state 31
    WHILE           shift and go to state 32
    FOR             shift and go to state 33
    {               shift and go to state 21

    Statement                      shift and go to state 96
    Assignment                     shift and go to state 25
    IfStatement                    shift and go to state 26
    WhileStatement                 shift and go to state 27
    ForStatement                   shift and go to state 28
    Block                          shift and go to state 30

state 87

    (26) WhileStatement -> WHILE ( Expression ) . Statement
    (18) Statement -> . Assignment
    (19) Statement -> . IfStatement
    (20) Statement -> . WhileStatement
    (21) Statement -> . ForStatement
    (22) Statement -> . ;
    (23) Statement -> . Block
    (28) Assignment -> . ID = Expression ;
    (25) IfStatement -> . IF ( Expression ) Statement ELSE Statement
    (26) WhileStatement -> . WHILE ( Expression ) Statement
    (27) ForStatement -> . FOR ( Assignment Expression ; Assignment ) Statement
    (24) Block -> . { Statements }

    ;               shift and go to state 29
    ID              shift and go to state 20
    IF              shift and go to state 31
    WHILE           shift and go to state 32
    FOR             shift and go to state 33
    {               shift and go to state 21

    Statement                      shift and go to state 97
    Assignment                     shift and go to state 25
    IfStatement                    shift and go to state 26
    WhileStatement                 shift and go to state 27
    ForStatement                   shift and go to state 28
    Block                          shift and go to state 30

state 88

    (27) ForStatement -> FOR ( Assignment Expression . ; Assignment ) Statement
    (30) Expression -> Expression . OR Conjunction

    ;               shift and go to state 98
    OR              shift and go to state 67


state 89

    (58) Primary -> ID ( ) .

    *               reduce using rule 58 (Primary -> ID ( ) .)
    /               reduce using rule 58 (Primary -> ID ( ) .)
    %               reduce using rule 58 (Primary -> ID ( ) .)
    <               reduce using rule 58 (Primary -> ID ( ) .)
    LTE             reduce using rule 58 (Primary -> ID ( ) .)
    >               reduce using rule 58 (Primary -> ID ( ) .)
    GTE             reduce using rule 58 (Primary -> ID ( ) .)
    +               reduce using rule 58 (Primary -> ID ( ) .)
    -               reduce using rule 58 (Primary -> ID ( ) .)
    EQ              reduce using rule 58 (Primary -> ID ( ) .)
    NEQ             reduce using rule 58 (Primary -> ID ( ) .)
    AND             reduce using rule 58 (Primary -> ID ( ) .)
    ;               reduce using rule 58 (Primary -> ID ( ) .)
    OR              reduce using rule 58 (Primary -> ID ( ) .)
    )               reduce using rule 58 (Primary -> ID ( ) .)


state 90

    (30) Expression -> Expression OR Conjunction .
    (32) Conjunction -> Conjunction . AND Equality

    ;               reduce using rule 30 (Expression -> Expression OR Conjunction .)
    OR              reduce using rule 30 (Expression -> Expression OR Conjunction .)
    )               reduce using rule 30 (Expression -> Expression OR Conjunction .)
    AND             shift and go to state 68


state 91

    (32) Conjunction -> Conjunction AND Equality .

    AND             reduce using rule 32 (Conjunction -> Conjunction AND Equality .)
    ;               reduce using rule 32 (Conjunction -> Conjunction AND Equality .)
    OR              reduce using rule 32 (Conjunction -> Conjunction AND Equality .)
    )               reduce using rule 32 (Conjunction -> Conjunction AND Equality .)


state 92

    (34) Equality -> Relation EquOp Relation .

    AND             reduce using rule 34 (Equality -> Relation EquOp Relation .)
    ;               reduce using rule 34 (Equality -> Relation EquOp Relation .)
    OR              reduce using rule 34 (Equality -> Relation EquOp Relation .)
    )               reduce using rule 34 (Equality -> Relation EquOp Relation .)


state 93

    (38) Relation -> Addition RelOp Addition .
    (44) Addition -> Addition . AddOp Term
    (45) AddOp -> . +
    (46) AddOp -> . -

    EQ              reduce using rule 38 (Relation -> Addition RelOp Addition .)
    NEQ             reduce using rule 38 (Relation -> Addition RelOp Addition .)
    AND             reduce using rule 38 (Relation -> Addition RelOp Addition .)
    ;               reduce using rule 38 (Relation -> Addition RelOp Addition .)
    OR              reduce using rule 38 (Relation -> Addition RelOp Addition .)
    )               reduce using rule 38 (Relation -> Addition RelOp Addition .)
    +               shift and go to state 78
    -               shift and go to state 79

    AddOp                          shift and go to state 73

state 94

    (44) Addition -> Addition AddOp Term .
    (48) Term -> Term . MulOp Primary
    (49) MulOp -> . *
    (50) MulOp -> . /
    (51) MulOp -> . %

    <               reduce using rule 44 (Addition -> Addition AddOp Term .)
    LTE             reduce using rule 44 (Addition -> Addition AddOp Term .)
    >               reduce using rule 44 (Addition -> Addition AddOp Term .)
    GTE             reduce using rule 44 (Addition -> Addition AddOp Term .)
    +               reduce using rule 44 (Addition -> Addition AddOp Term .)
    -               reduce using rule 44 (Addition -> Addition AddOp Term .)
    EQ              reduce using rule 44 (Addition -> Addition AddOp Term .)
    NEQ             reduce using rule 44 (Addition -> Addition AddOp Term .)
    AND             reduce using rule 44 (Addition -> Addition AddOp Term .)
    ;               reduce using rule 44 (Addition -> Addition AddOp Term .)
    OR              reduce using rule 44 (Addition -> Addition AddOp Term .)
    )               reduce using rule 44 (Addition -> Addition AddOp Term .)
    *               shift and go to state 81
    /               shift and go to state 82
    %               shift and go to state 83

    MulOp                          shift and go to state 80

state 95

    (48) Term -> Term MulOp Primary .

    *               reduce using rule 48 (Term -> Term MulOp Primary .)
    /               reduce using rule 48 (Term -> Term MulOp Primary .)
    %               reduce using rule 48 (Term -> Term MulOp Primary .)
    <               reduce using rule 48 (Term -> Term MulOp Primary .)
    LTE             reduce using rule 48 (Term -> Term MulOp Primary .)
    >               reduce using rule 48 (Term -> Term MulOp Primary .)
    GTE             reduce using rule 48 (Term -> Term MulOp Primary .)
    +               reduce using rule 48 (Term -> Term MulOp Primary .)
    -               reduce using rule 48 (Term -> Term MulOp Primary .)
    EQ              reduce using rule 48 (Term -> Term MulOp Primary .)
    NEQ             reduce using rule 48 (Term -> Term MulOp Primary .)
    AND             reduce using rule 48 (Term -> Term MulOp Primary .)
    ;               reduce using rule 48 (Term -> Term MulOp Primary .)
    OR              reduce using rule 48 (Term -> Term MulOp Primary .)
    )               reduce using rule 48 (Term -> Term MulOp Primary .)


state 96

    (25) IfStatement -> IF ( Expression ) Statement . ELSE Statement

    ELSE            shift and go to state 99


state 97

    (26) WhileStatement -> WHILE ( Expression ) Statement .

    ;               reduce using rule 26 (WhileStatement -> WHILE ( Expression ) Statement .)
    ID              reduce using rule 26 (WhileStatement -> WHILE ( Expression ) Statement .)
    IF              reduce using rule 26 (WhileStatement -> WHILE ( Expression ) Statement .)
    WHILE           reduce using rule 26 (WhileStatement -> WHILE ( Expression ) Statement .)
    FOR             reduce using rule 26 (WhileStatement -> WHILE ( Expression ) Statement .)
    {               reduce using rule 26 (WhileStatement -> WHILE ( Expression ) Statement .)
    RETURN          reduce using rule 26 (WhileStatement -> WHILE ( Expression ) Statement .)
    }               reduce using rule 26 (WhileStatement -> WHILE ( Expression ) Statement .)
    ELSE            reduce using rule 26 (WhileStatement -> WHILE ( Expression ) Statement .)


state 98

    (27) ForStatement -> FOR ( Assignment Expression ; . Assignment ) Statement
    (28) Assignment -> . ID = Expression ;

    ID              shift and go to state 20

    Assignment                     shift and go to state 100

state 99

    (25) IfStatement -> IF ( Expression ) Statement ELSE . Statement
    (18) Statement -> . Assignment
    (19) Statement -> . IfStatement
    (20) Statement -> . WhileStatement
    (21) Statement -> . ForStatement
    (22) Statement -> . ;
    (23) Statement -> . Block
    (28) Assignment -> . ID = Expression ;
    (25) IfStatement -> . IF ( Expression ) Statement ELSE Statement
    (26) WhileStatement -> . WHILE ( Expression ) Statement
    (27) ForStatement -> . FOR ( Assignment Expression ; Assignment ) Statement
    (24) Block -> . { Statements }

    ;               shift and go to state 29
    ID              shift and go to state 20
    IF              shift and go to state 31
    WHILE           shift and go to state 32
    FOR             shift and go to state 33
    {               shift and go to state 21

    Statement                      shift and go to state 101
    Assignment                     shift and go to state 25
    IfStatement                    shift and go to state 26
    WhileStatement                 shift and go to state 27
    ForStatement                   shift and go to state 28
    Block                          shift and go to state 30

state 100

    (27) ForStatement -> FOR ( Assignment Expression ; Assignment . ) Statement

    )               shift and go to state 102


state 101

    (25) IfStatement -> IF ( Expression ) Statement ELSE Statement .

    ;               reduce using rule 25 (IfStatement -> IF ( Expression ) Statement ELSE Statement .)
    ID              reduce using rule 25 (IfStatement -> IF ( Expression ) Statement ELSE Statement .)
    IF              reduce using rule 25 (IfStatement -> IF ( Expression ) Statement ELSE Statement .)
    WHILE           reduce using rule 25 (IfStatement -> IF ( Expression ) Statement ELSE Statement .)
    FOR             reduce using rule 25 (IfStatement -> IF ( Expression ) Statement ELSE Statement .)
    {               reduce using rule 25 (IfStatement -> IF ( Expression ) Statement ELSE Statement .)
    RETURN          reduce using rule 25 (IfStatement -> IF ( Expression ) Statement ELSE Statement .)
    }               reduce using rule 25 (IfStatement -> IF ( Expression ) Statement ELSE Statement .)
    ELSE            reduce using rule 25 (IfStatement -> IF ( Expression ) Statement ELSE Statement .)


state 102

    (27) ForStatement -> FOR ( Assignment Expression ; Assignment ) . Statement
    (18) Statement -> . Assignment
    (19) Statement -> . IfStatement
    (20) Statement -> . WhileStatement
    (21) Statement -> . ForStatement
    (22) Statement -> . ;
    (23) Statement -> . Block
    (28) Assignment -> . ID = Expression ;
    (25) IfStatement -> . IF ( Expression ) Statement ELSE Statement
    (26) WhileStatement -> . WHILE ( Expression ) Statement
    (27) ForStatement -> . FOR ( Assignment Expression ; Assignment ) Statement
    (24) Block -> . { Statements }

    ;               shift and go to state 29
    ID              shift and go to state 20
    IF              shift and go to state 31
    WHILE           shift and go to state 32
    FOR             shift and go to state 33
    {               shift and go to state 21

    Assignment                     shift and go to state 25
    Statement                      shift and go to state 103
    IfStatement                    shift and go to state 26
    WhileStatement                 shift and go to state 27
    ForStatement                   shift and go to state 28
    Block                          shift and go to state 30

state 103

    (27) ForStatement -> FOR ( Assignment Expression ; Assignment ) Statement .

    ;               reduce using rule 27 (ForStatement -> FOR ( Assignment Expression ; Assignment ) Statement .)
    ID              reduce using rule 27 (ForStatement -> FOR ( Assignment Expression ; Assignment ) Statement .)
    IF              reduce using rule 27 (ForStatement -> FOR ( Assignment Expression ; Assignment ) Statement .)
    WHILE           reduce using rule 27 (ForStatement -> FOR ( Assignment Expression ; Assignment ) Statement .)
    FOR             reduce using rule 27 (ForStatement -> FOR ( Assignment Expression ; Assignment ) Statement .)
    {               reduce using rule 27 (ForStatement -> FOR ( Assignment Expression ; Assignment ) Statement .)
    RETURN          reduce using rule 27 (ForStatement -> FOR ( Assignment Expression ; Assignment ) Statement .)
    }               reduce using rule 27 (ForStatement -> FOR ( Assignment Expression ; Assignment ) Statement .)
    ELSE            reduce using rule 27 (ForStatement -> FOR ( Assignment Expression ; Assignment ) Statement .)

